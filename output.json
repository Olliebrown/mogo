[
  {
    "number": 2,
    "title": "Data Structure Primitives",
    "sections": [
      {
        "number": 2.1,
        "title": "Constructors",
        "commands": [
          {
            "command": "word",
            "description": "<pre class=\"example\">WORD word1 word2\n(WORD word1 word2 word3 ...)</pre><p>outputs a word formed by concatenating its inputs.</p>",
            "seeAlso": []
          },
          {
            "command": "list",
            "description": "<pre class=\"example\">LIST thing1 thing2\n(LIST thing1 thing2 thing3 ...)</pre><p>outputs a list whose members are its inputs, which can be any Logo datum (word, list, or array).</p>",
            "seeAlso": []
          },
          {
            "command": "sentence",
            "description": "<pre class=\"example\">SENTENCE thing1 thing2\nSE thing1 thing2\n(SENTENCE thing1 thing2 thing3 ...)\n(SE thing1 thing2 thing3 ...)</pre><p>outputs a list whose members are its inputs, if those inputs are not lists, or the members of its inputs, if those inputs are lists.</p>",
            "seeAlso": []
          },
          {
            "command": "fput",
            "description": "<pre class=\"example\">FPUT thing list</pre><p>outputs a list equal to its second input with one extra member, the first input, at the beginning.  If the second input is a word, then the first input must be a one-letter word, and FPUT is equivalent to WORD.</p>",
            "seeAlso": []
          },
          {
            "command": "lput",
            "description": "<pre class=\"example\">LPUT thing list</pre><p>outputs a list equal to its second input with one extra member, the first input, at the end.  If the second input is a word, then the first input must be a one-letter word, and LPUT is equivalent to WORD with its inputs in the other order.</p>",
            "seeAlso": []
          },
          {
            "command": "array",
            "description": "<pre class=\"example\">ARRAY size\n(ARRAY size origin)</pre><p>outputs an array of <var>size</var> members (must be a positive integer), each of which initially is an empty list.  Array members can be selected with <code>ITEM</code> and changed with <code>SETITEM</code>.  The first member of the array is member number 1 unless an <var>origin</var> input (must be an integer) is given, in which case the first member of the array has that number as its index. (Typically 0 is used as the origin if anything.)  Arrays are printed by <code>PRINT</code> and friends, and can be typed in, inside curly braces; indicate an origin with <tt>{a b c}@0</tt>.</p>",
            "seeAlso": [
              "item",
              "setitem",
              "print"
            ]
          },
          {
            "command": "mdarray",
            "description": "<pre class=\"example\">MDARRAY sizelist\n(MDARRAY sizelist origin)</pre><p>outputs a multi-dimensional array.  The first input must be a list of one or more positive integers.  The second input, if present, must be a single integer that applies to every dimension of the array.  </p><p>Ex: <tt>(MDARRAY [3 5] 0)</tt> outputs a two-dimensional array whose members range from <tt>[0 0]</tt> to <tt>[2 4]</tt>.</p>",
            "seeAlso": []
          },
          {
            "command": "listtoarray",
            "description": "<pre class=\"example\">LISTTOARRAY list\n(LISTTOARRAY list origin)</pre><p>outputs an array of the same size as the input list, whose members are the members of the input list.</p>",
            "seeAlso": []
          },
          {
            "command": "arraytolist",
            "description": "<pre class=\"example\">ARRAYTOLIST array</pre><p>outputs a list whose members are the members of the input array.  The first member of the output is the first member of the array, regardless of the array&apos;s origin.</p>",
            "seeAlso": []
          },
          {
            "command": "combine",
            "description": "<pre class=\"example\">COMBINE thing1 thing2</pre><p>if <var>thing2</var> is a word, outputs <tt>WORD thing1 thing2</tt>.  If <var>thing2</var> is a list, outputs <tt>FPUT thing1 thing2</tt>.</p>",
            "seeAlso": [
              "word",
              "fput"
            ]
          },
          {
            "command": "reverse",
            "description": "<pre class=\"example\">REVERSE list</pre><p>outputs a list whose members are the members of the input list, in reverse order.</p>",
            "seeAlso": []
          },
          {
            "command": "gensym",
            "description": "<pre class=\"example\">GENSYM</pre><p>outputs a unique word each time it&apos;s invoked.  The words are of the form <code>G1</code>, <code>G2</code>, etc.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 2.2,
        "title": "Data Selectors",
        "commands": [
          {
            "command": "first",
            "description": "<pre class=\"example\">FIRST thing</pre><p>if the input is a word, outputs the first character of the word.  If the input is a list, outputs the first member of the list.  If the input is an array, outputs the origin of the array (that is, the <em>index of</em> the first member of the array).</p>",
            "seeAlso": []
          },
          {
            "command": "firsts",
            "description": "<pre class=\"example\">FIRSTS list</pre><p>outputs a list containing the <code>FIRST</code> of each member of the input list. It is an error if any member of the input list is empty.  (The input itself may be empty, in which case the output is also empty.)  This could be written as</p><pre class=\"example\">to firsts :list\noutput map &quot;first :list\nend</pre><p>but is provided as a primitive in order to speed up the iteration tools <code>MAP</code>, <code>MAP.SE</code>, and <code>FOREACH</code>.</p><pre class=\"example\">to transpose :matrix\nif emptyp first :matrix [op []]\nop fput firsts :matrix transpose bfs :matrix\nend</pre>",
            "seeAlso": [
              "map",
              "map.se",
              "foreach"
            ]
          },
          {
            "command": "last",
            "description": "<pre class=\"example\">LAST wordorlist</pre><p>if the input is a word, outputs the last character of the word.  If the input is a list, outputs the last member of the list.</p>",
            "seeAlso": []
          },
          {
            "command": "butfirst",
            "description": "<pre class=\"example\">BUTFIRST wordorlist\nBF wordorlist</pre><p>if the input is a word, outputs a word containing all but the first character of the input.  If the input is a list, outputs a list containing all but the first member of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "butfirsts",
            "description": "<pre class=\"example\">BUTFIRSTS list\nBFS list</pre><p>outputs a list containing the <code>BUTFIRST</code> of each member of the input list. It is an error if any member of the input list is empty or an array. (The input itself may be empty, in which case the output is also empty.) This could be written as</p><pre class=\"example\">to butfirsts :list\noutput map &quot;butfirst :list\nend</pre><p>but is provided as a primitive in order to speed up the iteration tools <code>MAP</code>, <code>MAP.SE</code>, and <code>FOREACH</code>.</p>",
            "seeAlso": [
              "map",
              "map.se",
              "foreach"
            ]
          },
          {
            "command": "butlast",
            "description": "<pre class=\"example\">BUTLAST wordorlist\nBL wordorlist</pre><p>if the input is a word, outputs a word containing all but the last character of the input.  If the input is a list, outputs a list containing all but the last member of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "item",
            "description": "<pre class=\"example\">ITEM index thing</pre><p>if the <var>thing</var> is a word, outputs the <var>index</var>th character of the word. If the <var>thing</var> is a list, outputs the <var>index</var>th member of the list.  If the <var>thing</var> is an array, outputs the <var>index</var>th member of the array. <var>Index</var> starts at 1 for words and lists; the starting index of an array is specified when the array is created.</p>",
            "seeAlso": []
          },
          {
            "command": "mditem",
            "description": "<pre class=\"example\">MDITEM indexlist array</pre><p>outputs the member of the multidimensional <var>array</var> selected by the list of numbers <var>indexlist</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "pick",
            "description": "<pre class=\"example\">PICK list</pre><p>outputs a randomly chosen member of the input list.</p>",
            "seeAlso": []
          },
          {
            "command": "remove",
            "description": "<pre class=\"example\">REMOVE thing list</pre><p>outputs a copy of <var>list</var> with every member equal to <var>thing</var> removed.</p>",
            "seeAlso": []
          },
          {
            "command": "remdup",
            "description": "<pre class=\"example\">REMDUP list</pre><p>outputs a copy of <var>list</var> with duplicate members removed.  If two or more members of the input are equal, the rightmost of those members is the one that remains in the output.</p>",
            "seeAlso": []
          },
          {
            "command": "quoted",
            "description": "<pre class=\"example\">QUOTED thing</pre><p>outputs its input, if a list; outputs its input with a quotation mark prepended, if a word.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 2.3,
        "title": "Data Mutators",
        "commands": [
          {
            "command": "setitem",
            "description": "<pre class=\"example\">SETITEM index array value</pre><p>command.  Replaces the <var>index</var>th member of <var>array</var> with the new <var>value</var>. Ensures that the resulting array is not circular, i.e., <var>value</var> may not be a list or array that contains <var>array</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "mdsetitem",
            "description": "<pre class=\"example\">MDSETITEM indexlist array value</pre><p>command.  Replaces the member of <var>array</var> chosen by <var>indexlist</var> with the new <var>value</var>.</p>",
            "seeAlso": []
          },
          {
            "command": ".setfirst",
            "description": "<pre class=\"example\">.SETFIRST list value</pre><p>command.  Changes the first member of <var>list</var> to be <var>value</var>.</p><p>WARNING: Primitives whose names start with a period are <strong>dangerous</strong>. Their use by non-experts is not recommended.  The use of <code>.SETFIRST</code> can lead to circular list structures, which will get some Logo primitives into infinite loops, and to unexpected changes to other data structures that share storage with the list being modified.</p>",
            "seeAlso": []
          },
          {
            "command": ".setbf",
            "description": "<pre class=\"example\">.SETBF list value</pre><p>command.  Changes the butfirst of <var>list</var> to be <var>value</var>.</p><p>WARNING: Primitives whose names start with a period are <strong>dangerous</strong>. Their use by non-experts is not recommended.  The use of <code>.SETBF</code> can lead to circular list structures, which will get some Logo primitives into infinite loops; unexpected changes to other data structures that share storage with the list being modified; or to Logo crashes and coredumps if the butfirst of a list is not itself a list.</p>",
            "seeAlso": []
          },
          {
            "command": ".setitem",
            "description": "<pre class=\"example\">.SETITEM index array value</pre><p>command.  Changes the <var>index</var>th member of <var>array</var> to be <var>value</var>, like <code>SETITEM</code>, but without checking for circularity.</p><p>WARNING: Primitives whose names start with a period are <b>dangerous</b>. Their use by non-experts is not recommended.  The use of <code>.SETITEM</code> can lead to circular arrays, which will get some Logo primitives into infinite loops.</p>",
            "seeAlso": [
              "setitem"
            ]
          },
          {
            "command": "push",
            "description": "<pre class=\"example\">PUSH stackname thing</pre><p>command.  Adds the <var>thing</var> to the stack that is the value of the variable whose name is <var>stackname</var>.  This variable must have a list as its value; the initial value should be the empty list.  New members are added at the front of the list.</p>",
            "seeAlso": []
          },
          {
            "command": "pop",
            "description": "<pre class=\"example\">POP stackname</pre><p>outputs the most recently <code>PUSH</code>ed member of the stack that is the value of the variable whose name is <var>stackname</var> and removes that member from the stack.</p>",
            "seeAlso": []
          },
          {
            "command": "queue",
            "description": "<pre class=\"example\">QUEUE queuename thing</pre><p>command.  Adds the <var>thing</var> to the queue that is the value of the variable whose name is <var>queuename</var>.  This variable must have a list as its value; the initial value should be the empty list.  New members are added at the back of the list.</p>",
            "seeAlso": []
          },
          {
            "command": "dequeue",
            "description": "<pre class=\"example\">DEQUEUE queuename</pre><p>outputs the least recently <code>QUEUE</code>d member of the queue that is the value of the variable whose name is <var>queuename</var> and removes that member from the queue.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 2.4,
        "title": "Predicates",
        "commands": [
          {
            "command": "wordp",
            "description": "<pre class=\"example\">WORDP thing\nWORD? thing</pre><p>outputs <code>TRUE</code> if the input is a word, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "listp",
            "description": "<pre class=\"example\">LISTP thing\nLIST? thing</pre><p>outputs <code>TRUE</code> if the input is a list, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "arrayp",
            "description": "<pre class=\"example\">ARRAYP thing\nARRAY? thing</pre><p>outputs <code>TRUE</code> if the input is an array, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "emptyp",
            "description": "<pre class=\"example\">EMPTYP thing\nEMPTY? thing</pre><p>outputs <code>TRUE</code> if the input is the empty word or the empty list, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "equalp",
            "description": "<pre class=\"example\">EQUALP thing1 thing2\nEQUAL? thing1 thing2\nthing1 = thing2</pre><p>outputs <code>TRUE</code> if the inputs are equal, <code>FALSE</code> otherwise.  Two numbers are equal if they have the same numeric value.  Two non-numeric words are equal if they contain the same characters in the same order.  If there is a variable named <code>CASEIGNOREDP</code> whose value is <code>TRUE</code>, then an upper case letter is considered the same as the corresponding lower case letter. (This is the case by default.)  Two lists are equal if their members are equal.  An array is only equal to itself; two separately created arrays are never equal even if their members are equal.  (It is important to be able to know if two expressions have the same array as their value because arrays are mutable; if, for example, two variables have the same array as their values then performing <code>SETITEM</code> on one of them will also change the other.)</p>",
            "seeAlso": [
              "caseignoredp",
              "setitem"
            ]
          },
          {
            "command": "notequalp",
            "description": "<pre class=\"example\">NOTEQUALP thing1 thing2\nNOTEQUAL? thing1 thing2\nthing1 &lt;&gt; thing2</pre><p>outputs <code>FALSE</code> if the inputs are equal, <code>TRUE</code> otherwise.  See <code>EQUALP</code> for the meaning of equality for different data types.</p>",
            "seeAlso": []
          },
          {
            "command": "beforep",
            "description": "<pre class=\"example\">BEFOREP word1 word2\nBEFORE? word1 word2</pre><p>outputs <code>TRUE</code> if <var>word1</var> comes before <var>word2</var> in ASCII collating sequence (for words of letters, in alphabetical order).  Case-sensitivity is determined by the value of <code>CASEIGNOREDP</code>.  Note that if the inputs are numbers, the result may not be the same as with <code>LESSP</code>; for example, <tt>BEFOREP 3 12</tt> is false because 3 collates after 1.</p>",
            "seeAlso": [
              "caseignoredp",
              "lessp"
            ]
          },
          {
            "command": ".eq",
            "description": "<pre class=\"example\">.EQ thing1 thing2</pre><p>outputs <code>TRUE</code> if its two inputs are the same datum, so that applying a mutator to one will change the other as well.  Outputs <code>FALSE</code> otherwise, even if the inputs are equal in value.  </p><p>WARNING: Primitives whose names start with a period are <strong>dangerous</strong>. Their use by non-experts is not recommended.  The use of mutators can lead to circular data structures, infinite loops, or Logo crashes.</p>",
            "seeAlso": []
          },
          {
            "command": "memberp",
            "description": "<pre class=\"example\">MEMBERP thing1 thing2\nMEMBER? thing1 thing2</pre><p>if <var>thing2</var> is a list or an array, outputs <code>TRUE</code> if <var>thing1</var> is <code>EQUALP</code> to a member of <var>thing2</var>, <code>FALSE</code> otherwise.  If <var>thing2</var> is a word, outputs <code>TRUE</code> if <var>thing1</var> is a one-character word <code>EQUALP</code> to a character of <var>thing2</var>, <code>FALSE</code> otherwise.</p>",
            "seeAlso": [
              "equalp"
            ]
          },
          {
            "command": "substringp",
            "description": "<pre class=\"example\">SUBSTRINGP thing1 thing2\nSUBSTRING? thing1 thing2</pre><p>if <var>thing1</var> or <var>thing2</var> is a list or an array, outputs <code>FALSE</code>.  If <var>thing2</var> is a word, outputs <code>TRUE</code> if <var>thing1</var> is <code>EQUALP</code> to a substring of <var>thing2</var>, <code>FALSE</code> otherwise.</p>",
            "seeAlso": [
              "equalp"
            ]
          },
          {
            "command": "numberp",
            "description": "<pre class=\"example\">NUMBERP thing\nNUMBER? thing</pre><p>outputs <code>TRUE</code> if the input is a number, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "vbarredp",
            "description": "<pre class=\"example\">VBARREDP char\nVBARRED? char\nBACKSLASHEDP char\nBACKSLASHED? char</pre><p>outputs <code>TRUE</code> if the input character was originally entered into Logo within vertical bars (|) to prevent its usual special syntactic meaning, <code>FALSE</code> otherwise.  (Outputs <code>TRUE</code> only if the character is a backslashed space, tab, newline, or one of <code>()[]+-*/=&lt;&gt;&quot;:;\\~?|</code> )</p><p>The names <code>BACKSLASHEDP</code> and <code>BACKSLASHED?</code> are included in the Logo library for backward compatibility with the former names of this primitive, although it does <em>not</em> output <code>TRUE</code> for characters originally entered with backslashes.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 2.5,
        "title": "Queries",
        "commands": [
          {
            "command": "count",
            "description": "<pre class=\"example\">COUNT thing</pre><p>outputs the number of characters in the input, if the input is a word; outputs the number of members in the input, if it is a list or an array. (For an array, this may or may not be the index of the last member, depending on the array&apos;s origin.)</p>",
            "seeAlso": []
          },
          {
            "command": "ascii",
            "description": "<pre class=\"example\">ASCII char</pre><p>outputs the integer (between 0 and 255) that represents the input character in the ASCII code.  Interprets control characters as representing vbarred punctuation, and returns the character code for the corresponding punctuation character without vertical bars.  (Compare <code>RAWASCII</code>.)</p>",
            "seeAlso": []
          },
          {
            "command": "rawascii",
            "description": "<pre class=\"example\">RAWASCII char</pre><p>outputs the integer (between 0 and 255) that represents the input character in the ASCII code.  Interprets control characters as representing themselves.  To find out the ASCII code of an arbitrary keystroke, use <tt>RAWASCII RC</tt>.</p>",
            "seeAlso": []
          },
          {
            "command": "char",
            "description": "<pre class=\"example\">CHAR int</pre><p>outputs the character represented in the ASCII code by the input, which must be an integer between 0 and 255.</p>",
            "seeAlso": [
              "ascii"
            ]
          },
          {
            "command": "member",
            "description": "<pre class=\"example\">MEMBER thing1 thing2</pre><p>if <var>thing2</var> is a word or list and if <code>MEMBERP</code> with these inputs would output <code>TRUE</code>, outputs the portion of <var>thing2</var> from the first instance of <var>thing1</var> to the end.  If <code>MEMBERP</code> would output <code>FALSE</code>, outputs the empty word or list according to the type of <var>thing2</var>.  It is an error for <var>thing2</var> to be an array.</p>",
            "seeAlso": [
              "memberp"
            ]
          },
          {
            "command": "lowercase",
            "description": "<pre class=\"example\">LOWERCASE word</pre><p>outputs a copy of the input word, but with all uppercase letters changed to the corresponding lowercase letter.</p>",
            "seeAlso": []
          },
          {
            "command": "uppercase",
            "description": "<pre class=\"example\">UPPERCASE word</pre><p>outputs a copy of the input word, but with all lowercase letters changed to the corresponding uppercase letter.</p>",
            "seeAlso": []
          },
          {
            "command": "standout",
            "description": "<pre class=\"example\">STANDOUT thing</pre><p>outputs a word that, when printed, will appear like the input but displayed in standout mode (boldface, reverse video, or whatever your version does for standout).  The word contains machine-specific magic characters at the beginning and end; in between is the printed form (as if displayed using <code>TYPE</code>) of the input.  The output is always a word, even if the input is of some other type, but it may include spaces and other formatting characters.  Note: a word output by <code>STANDOUT</code> while Logo is running on one machine will probably not have the desired effect if printed on another type of machine.</p><p>In the Macintosh classic version, the way that standout works is incompatible with the use of characters whose ASCII code is greater than 127.  Therefore, you have a choice to make:  The instruction </p><pre class=\"example\">CANINVERSE 0 </pre><p>disables standout, but enables the display of ASCII codes above 127, and the instruction</p><pre class=\"example\">CANINVERSE 1 </pre><p>restores the default situation in which standout is enabled and the extra graphic characters cannot be printed.</p>",
            "seeAlso": []
          },
          {
            "command": "parse",
            "description": "<pre class=\"example\">PARSE word</pre><p>outputs the list that would result if the input word were entered in response to a <code>READLIST</code> operation.  That is, <tt>PARSE READWORD</tt> has the same value as <code>READLIST</code> for the same characters read.</p>",
            "seeAlso": [
              "readlist",
              "readword"
            ]
          },
          {
            "command": "runparse",
            "description": "<pre class=\"example\">RUNPARSE wordorlist</pre><p>outputs the list that would result if the input word or list were entered as an instruction line; characters such as infix operators and parentheses are separate members of the output.  Note that sublists of a runparsed list are not themselves runparsed.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  },
  {
    "number": 3,
    "title": "Communication",
    "sections": [
      {
        "number": 3.1,
        "title": "Transmitters",
        "commands": [
          {
            "command": "print",
            "description": "<pre class=\"example\">PRINT thing\nPR thing\n(PRINT thing1 thing2 ...)\n(PR thing1 thing2 ...)</pre><p>command.  Prints the input or inputs to the current write stream (initially the screen).  All the inputs are printed on a single line, separated by spaces, ending with a newline.  If an input is a list, square brackets are not printed around it, but brackets are printed around sublists.  Braces are always printed around arrays.</p>",
            "seeAlso": []
          },
          {
            "command": "type",
            "description": "<pre class=\"example\">TYPE thing\n(TYPE thing1 thing2 ...)</pre><p>command.  Prints the input or inputs like <code>PRINT</code>, except that no newline character is printed at the end and multiple inputs are not separated by spaces.  Note: printing to the screen is ordinarily <em>line buffered</em>; that is, the characters you print using <code>TYPE</code> will not actually appear on the screen until either a newline character is printed (for example, by <code>PRINT</code> or <code>SHOW</code>) or Logo tries to read from the keyboard (either at the request of your program or after an instruction prompt).  This buffering makes the program much faster than it would be if each character appeared immediately, and in most cases the effect is not disconcerting. To accommodate programs that do a lot of positioned text display using <code>TYPE</code>, Logo will force printing whenever <code>SETCURSOR</code> is invoked.  This solves most buffering problems.  Still, on occasion you may find it necessary to force the buffered characters to be printed explicitly; this can be done using the <code>WAIT</code> command.  <tt>WAIT 0</tt> will force printing without actually waiting.</p>",
            "seeAlso": [
              "setcursor",
              "wait"
            ]
          },
          {
            "command": "show",
            "description": "<pre class=\"example\">SHOW thing\n(SHOW thing1 thing2 ...)</pre><p>command.  Prints the input or inputs like <code>PRINT</code>, except that if an input is a list it is printed inside square brackets.</p>",
            "seeAlso": [
              "print"
            ]
          }
        ]
      },
      {
        "number": 3.2,
        "title": "Receivers",
        "commands": [
          {
            "command": "readlist",
            "description": "<pre class=\"example\">READLIST\nRL</pre><p>reads a line from the read stream (initially the keyboard) and outputs that line as a list.  The line is separated into members as though it were typed in square brackets in an instruction.  If the read stream is a file, and the end of file is reached, <code>READLIST</code> outputs the empty word (not the empty list).  <code>READLIST</code> processes backslash, vertical bar, and tilde characters in the read stream; the output list will not contain these characters but they will have had their usual effect.  <code>READLIST</code> does not, however, treat semicolon as a comment character.</p>",
            "seeAlso": []
          },
          {
            "command": "readword",
            "description": "<pre class=\"example\">READWORD\nRW</pre><p>reads a line from the read stream and outputs that line as a word.  The output is a single word even if the line contains spaces, brackets, etc. If the read stream is a file, and the end of file is reached, <code>READWORD</code> outputs the empty list (not the empty word).  <code>READWORD</code> processes backslash, vertical bar, and tilde characters in the read stream.  In the case of a tilde used for line continuation, the output word <em>does</em> include the tilde and the newline characters, so that the user program can tell exactly what the user entered.  Vertical bars in the line are also preserved in the output.  Backslash characters are not preserved in the output.</p>",
            "seeAlso": []
          },
          {
            "command": "readrawline",
            "description": "<pre class=\"example\">READRAWLINE</pre><p>reads a line from the read stream and outputs that line as a word.  The output is a single word even if the line contains spaces, brackets, etc. If the read stream is a file, and the end of file is reached, <code>READRAWLINE</code> outputs the empty list (not the empty word).  <code>READRAWLINE</code> outputs the exact string of characters as they appear in the line, with no special meaning for backslash, vertical bar, tilde, or any other formatting characters.</p>",
            "seeAlso": [
              "readword"
            ]
          },
          {
            "command": "readchar",
            "description": "<pre class=\"example\">READCHAR\nRC</pre><p>reads a single character from the read stream and outputs that character as a word.  If the read stream is a file, and the end of file is reached, <code>READCHAR</code> outputs the empty list (not the empty word).  If the read stream is the keyboard, echoing is turned off when <code>READCHAR</code> is invoked, and remains off until <code>READLIST</code> or <code>READWORD</code> is invoked or a Logo prompt is printed.  Backslash, vertical bar, and tilde characters have no special meaning in this context.</p>",
            "seeAlso": [
              "readlist"
            ]
          },
          {
            "command": "readchars",
            "description": "<pre class=\"example\">READCHARS num\nRCS num</pre><p>reads <var>num</var> characters from the read stream and outputs those characters as a word.  If the read stream is a file, and the end of file is reached, <code>READCHARS</code> outputs the empty list (not the empty word).  If the read stream is the keyboard, echoing is turned off when <code>READCHARS</code> is invoked, and remains off until <code>READLIST</code> or <code>READWORD</code> is invoked or a Logo prompt is printed.  Backslash, vertical bar, and tilde characters have no special meaning in this context.</p>",
            "seeAlso": [
              "readlist",
              "readword"
            ]
          },
          {
            "command": "shell",
            "description": "<pre class=\"example\">SHELL command\n(SHELL command wordflag)</pre><p>Under Unix, outputs the result of running <var>command</var> as a shell command. (The command is sent to &#x2018;<samp>/bin/sh</samp>&#x2019;, not &#x2018;<samp>csh</samp>&#x2019; or other alternatives.) If the command is a literal list in the instruction line, and if you want a backslash character sent to the shell, you must use <code>\\\\</code> to get the backslash through Logo&apos;s reader intact.  The output is a list containing one member for each line generated by the shell command.  Ordinarily each such line is represented by a list in the output, as though the line were read using <code>READLIST</code>.  If a second input is given, regardless of the value of the input, each line is represented by a word in the output as though it were read with <code>READWORD</code>.  Example:</p><pre class=\"example\">to dayofweek\noutput first first shell [date]\nend</pre><p>This is <code>first first</code> to extract the first word of the first (and only) line of the shell output.</p><p>Under MacOS X, <code>SHELL</code> works as under Unix.  <code>SHELL</code> is not available under Mac Classic.</p><p>Under DOS, <code>SHELL</code> is a command, not an operation; it sends its input to a DOS command processor but does not collect the result of the command.</p><p>Under Windows, the wxWidgets version of Logo behaves as under Unix (except that DOS-style commands are understood; use <code>dir</code> rather than <code>ls</code>). The non-wxWidgets version behaves like the DOS version.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 3.3,
        "title": "File Access",
        "commands": [
          {
            "command": "setprefix",
            "description": "<pre class=\"example\">SETPREFIX string</pre><p>command.  Sets a prefix that will be used as the implicit beginning of filenames in <code>OPENREAD</code>, <code>OPENWRITE</code>, <code>OPENAPPEND</code>, <code>OPENUPDATE</code>, <code>LOAD</code>, and <code>SAVE</code> commands.  Logo will put the appropriate separator character (slash for Unix, backslash for DOS/Windows, colon for MacOS Classic) between the prefix and the filename entered by the user.  The input to <code>SETPREFIX</code> must be a word, unless it is the empty list, to indicate that there should be no prefix.</p>",
            "seeAlso": [
              "openread",
              "openwrite",
              "openappend",
              "openupdate",
              "load",
              "save"
            ]
          },
          {
            "command": "prefix",
            "description": "<pre class=\"example\">PREFIX</pre><p>outputs the current file prefix, or [] if there is no prefix.</p>",
            "seeAlso": [
              "setprefix"
            ]
          },
          {
            "command": "openread",
            "description": "<pre class=\"example\">OPENREAD filename</pre><p>command.  Opens the named file for reading.  The read position is initially at the beginning of the file.</p>",
            "seeAlso": []
          },
          {
            "command": "openwrite",
            "description": "<pre class=\"example\">OPENWRITE filename</pre><p>command.  Opens the named file for writing.  If the file already existed, the old version is deleted and a new, empty file created.</p><p><code>OPENWRITE</code>, but not the other <code>OPEN</code> variants, will accept as input a two-element list, in which the first element must be a variable name, and the second must be a positive integer.  A character buffer of the specified size will be created.  When a <code>SETWRITE</code> is done with this same list (in the sense of .EQ, not a copy, so you must do something like</p><pre class=\"example\">? make &quot;buf [foo 100]\n? openwrite :buf\n? setwrite :buf\n    [...]\n? close :buf</pre><p>and not just</p><pre class=\"example\">? openwrite [foo 100]\n? setwrite [foo 100]</pre><p>and so on), the printed characters are stored in the buffer; when a <code>CLOSE</code> is done with the same list as input, the characters from the buffer (treated as one long word, even if spaces and newlines are included) become the value of the specified variable.</p>",
            "seeAlso": []
          },
          {
            "command": "openappend",
            "description": "<pre class=\"example\">OPENAPPEND filename</pre><p>command.  Opens the named file for writing.  If the file already exists, the write position is initially set to the end of the old file, so that newly written data will be appended to it.</p>",
            "seeAlso": []
          },
          {
            "command": "openupdate",
            "description": "<pre class=\"example\">OPENUPDATE filename</pre><p>command.  Opens the named file for reading and writing.  The read and write position is initially set to the end of the old file, if any. Note: each open file has only one position, for both reading and writing.  If a file opened for update is both <code>READER</code> and <code>WRITER</code> at the same time, then <code>SETREADPOS</code> will also affect <code>WRITEPOS</code> and vice versa. Also, if you alternate reading and writing the same file, you must <code>SETREADPOS</code> between a write and a read, and <code>SETWRITEPOS</code> between a read and a write.</p>",
            "seeAlso": [
              "reader",
              "writer",
              "setreadpos",
              "setwritepos"
            ]
          },
          {
            "command": "close",
            "description": "<pre class=\"example\">CLOSE filename</pre><p>command.  Closes the named file.  If the file was currently the reader or writer, then the reader or writer is changed to the keyboard or screen, as if <tt>SETREAD []</tt> or <tt>SETWRITE []</tt> had been done.</p>",
            "seeAlso": []
          },
          {
            "command": "allopen",
            "description": "<pre class=\"example\">ALLOPEN</pre><p>outputs a list whose members are the names of all files currently open. This list does not include the dribble file, if any.</p>",
            "seeAlso": []
          },
          {
            "command": "closeall",
            "description": "<pre class=\"example\">CLOSEALL</pre><p>command. Closes all open files. Abbreviates <tt>FOREACH ALLOPEN [CLOSE ?]</tt></p>",
            "seeAlso": [
              "foreach",
              "close"
            ]
          },
          {
            "command": "erasefile",
            "description": "<pre class=\"example\">ERASEFILE filename\nERF filename</pre><p>command.  Erases (deletes, removes) the named file, which should not currently be open.</p>",
            "seeAlso": []
          },
          {
            "command": "dribble",
            "description": "<pre class=\"example\">DRIBBLE filename</pre><p>command.  Creates a new file whose name is the input, like <code>OPENWRITE</code>, and begins recording in that file everything that is read from the keyboard or written to the terminal.  That is, this writing is in addition to the writing to <code>WRITER</code>.  The intent is to create a transcript of a Logo session, including things like prompt characters and interactions.</p>",
            "seeAlso": [
              "openwrite",
              "writer"
            ]
          },
          {
            "command": "nodribble",
            "description": "<pre class=\"example\">NODRIBBLE</pre><p>command.  Stops copying information into the dribble file, and closes the file.</p>",
            "seeAlso": []
          },
          {
            "command": "setread",
            "description": "<pre class=\"example\">SETREAD filename</pre><p>command.  Makes the named file the read stream, used for <code>READLIST</code>, etc. The file must already be open with <code>OPENREAD</code> or <code>OPENUPDATE</code>.  If the input is the empty list, then the read stream becomes the keyboard, as usual. Changing the read stream does not close the file that was previously the read stream, so it is possible to alternate between files.</p>",
            "seeAlso": [
              "readlist",
              "openread",
              "openupdate"
            ]
          },
          {
            "command": "setwrite",
            "description": "<pre class=\"example\">SETWRITE filename</pre><p>command.  Makes the named file the write stream, used for <code>PRINT</code>, etc.  The file must already be open with <code>OPENWRITE</code>, <code>OPENAPPEND</code>, or <code>OPENUPDATE</code>.  If the input is the empty list, then the write stream becomes the screen, as usual.  Changing the write stream does not close the file that was previously the write stream, so it is possible to alternate between files.</p><p>If the input is a list, then its first element must be a variable name, and its second and last element must be a positive integer; a buffer of that many characters will be allocated, and will become the writestream.  If the same list (same in the <code>.EQ</code> sense, not a copy) has been used as input to <code>OPENWRITE</code>, then the already-allocated buffer will be used, and the writer can be changed to and from this buffer, with all the characters accumulated as in a file.  When the same list is used as input to <code>CLOSE</code>, the contents of the buffer (as an unparsed word, which may contain newline characters) will become the value of the named variable.  For compatibility with earlier versions, if the list has not been opened when the <code>SETWRITE</code> is done, it will be opened implicitly, but the first <code>SETWRITE</code> after this one will implicitly close it, setting the variable and freeing the allocated buffer.</p>",
            "seeAlso": [
              "print",
              "openwrite",
              "openappend",
              "openupdate"
            ]
          },
          {
            "command": "reader",
            "description": "<pre class=\"example\">READER</pre><p>outputs the name of the current read stream file, or the empty list if the read stream is the terminal.</p>",
            "seeAlso": []
          },
          {
            "command": "writer",
            "description": "<pre class=\"example\">WRITER</pre><p>outputs the name of the current write stream file, or the empty list if the write stream is the screen.</p>",
            "seeAlso": []
          },
          {
            "command": "setreadpos",
            "description": "<pre class=\"example\">SETREADPOS charpos</pre><p>command.  Sets the file pointer of the read stream file so that the next <code>READLIST</code>, etc., will begin reading at the <var>charpos</var>th character in the file, counting from 0.  (That is, <tt>SETREADPOS 0</tt> will start reading from the beginning of the file.)  Meaningless if the read stream is the keyboard.</p>",
            "seeAlso": [
              "readlist"
            ]
          },
          {
            "command": "setwritepos",
            "description": "<pre class=\"example\">SETWRITEPOS charpos</pre><p>command.  Sets the file pointer of the write stream file so that the next <code>PRINT</code>, etc., will begin writing at the <var>charpos</var>th character in the file, counting from 0.  (That is, <tt>SETWRITEPOS 0</tt> will start writing from the beginning of the file.)  Meaningless if the write stream is the screen.</p>",
            "seeAlso": [
              "print"
            ]
          },
          {
            "command": "readpos",
            "description": "<pre class=\"example\">READPOS</pre><p>outputs the file position of the current read stream file.</p>",
            "seeAlso": []
          },
          {
            "command": "writepos",
            "description": "<pre class=\"example\">WRITEPOS</pre><p>outputs the file position of the current write stream file.</p>",
            "seeAlso": []
          },
          {
            "command": "eofp",
            "description": "<pre class=\"example\">EOFP\nEOF?</pre><p>predicate, outputs <code>TRUE</code> if there are no more characters to be read in the read stream file, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          },
          {
            "command": "filep",
            "description": "<pre class=\"example\">FILEP filename\nFILE? filename</pre><p>predicate, outputs <code>TRUE</code> if a file of the specified name exists and can be read, <code>FALSE</code> otherwise.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 3.4,
        "title": "Terminal Access",
        "commands": [
          {
            "command": "keyp",
            "description": "<pre class=\"example\">KEYP\nKEY?</pre><p>predicate, outputs <code>TRUE</code> if there are characters waiting to be read from the read stream.  If the read stream is a file, this is equivalent to <tt>NOT EOFP</tt>.  If the read stream is the terminal, then echoing is turned off and the terminal is set to <code>cbreak</code> (character at a time instead of line at a time) mode.  It remains in this mode until some line-mode reading is requested (e.g., <code>READLIST</code>).  The Unix operating system forgets about any pending characters when it switches modes, so the first <code>KEYP</code> invocation will always output <code>FALSE</code>.</p>",
            "seeAlso": [
              "eofp",
              "readlist"
            ]
          },
          {
            "command": "cleartext",
            "description": "<pre class=\"example\">CLEARTEXT\nCT</pre><p>command.  Clears the text window.</p>",
            "seeAlso": []
          },
          {
            "command": "setcursor",
            "description": "<pre class=\"example\">SETCURSOR vector</pre><p>command.  The input is a list of two numbers, the x and y coordinates of a text window position (origin in the upper left corner, positive direction is southeast).  The text cursor is moved to the requested position. This command also forces the immediate printing of any buffered characters.</p>",
            "seeAlso": []
          },
          {
            "command": "cursor",
            "description": "<pre class=\"example\">CURSOR</pre><p>outputs a list containing the current x and y coordinates of the text cursor.  Logo may get confused about the current cursor position if, e.g., you type in a long line that wraps around or your program prints escape codes that affect the screen strangely.</p>",
            "seeAlso": []
          },
          {
            "command": "setmargins",
            "description": "<pre class=\"example\">SETMARGINS vector</pre><p>command.  The input must be a list of two numbers, as for <code>SETCURSOR</code>. The effect is to clear the screen and then arrange for all further printing to be shifted down and to the right according to the indicated margins.  Specifically, every time a newline character is printed (explicitly or implicitly) Logo will type <var>x_margin</var> spaces, and on every invocation of <code>SETCURSOR</code> the margins will be added to the input x and y coordinates.  (<code>CURSOR</code> will report the cursor position relative to the margins, so that this shift will be invisible to Logo programs.)  The purpose of this command is to accommodate the display of terminal screens in lecture halls with inadequate TV monitors that miss the top and left edges of the screen.</p>",
            "seeAlso": [
              "setcursor"
            ]
          },
          {
            "command": "settextcolor",
            "description": "<pre class=\"example\">SETTEXTCOLOR foreground background\nSETTC foreground background</pre><p>command (wxWidgets only).  The inputs are color numbers, or RGB color lists, as for turtle graphics.  The foreground and background colors for the textscreen/splitscreen text window are changed to the given values.  The change affects text already printed as well as future text printing; there is only one text color for the entire window.</p><p>Command (non-wxWidgets Windows and DOS extended only).  The inputs are color numbers, as for turtle graphics.  Future printing to the text window will use the specified colors for foreground (the characters printed) and background (the space under those characters).  Using <code>STANDOUT</code> will revert to the default text window colors.  In the DOS extended (&#x2018;<tt>ucblogo.exe</tt>&#x2019;) version, colors in textscreen mode are limited to numbers 0-7, and the coloring applies only to text printed by the program, not to the echoing of text typed by the user. Neither limitation applies to the text portion of splitscreen mode, which is actually drawn as graphics internally.</p>",
            "seeAlso": [
              "standout"
            ]
          },
          {
            "command": "increasefont",
            "description": "<pre class=\"example\">INCREASEFONT\nDECREASEFONT</pre><p>command (wxWidgets only).  Increase or decrease the size of the font used in the text and edit windows to the next larger or smaller available size.</p>",
            "seeAlso": []
          },
          {
            "command": "settextsize",
            "description": "<pre class=\"example\">SETTEXTSIZE height</pre><p>command (wxWidgets only).  Set the &quot;point size&quot; of the font used in the text and edit windows to the given integer input.  The desired size may not be available, in which case the nearest available size will be used.  Note: There is only a slight correlation between these integers and pixel sizes.  Our rough estimate is that the number of pixels of height is about 1.5 times the point size, but it varies for different fonts.  See <code>SETLABELHEIGHT</code> for a different approach used for the graphics window.</p>",
            "seeAlso": []
          },
          {
            "command": "textsize",
            "description": "<pre class=\"example\">TEXTSIZE</pre><p>(wxWidgets only) outputs the &quot;point size&quot; of the font used in the text and edit windows.  See <code>SETTEXTSIZE</code> for a discussion of font sizing. See <code>LABELSIZE</code> for a different approach used for the graphics window.</p>",
            "seeAlso": []
          },
          {
            "command": "setfont",
            "description": "<pre class=\"example\">SETFONT fontname</pre><p>command (wxWidgets only).  Set the font family used in all windows to the one named by the input.  Try &#x2018;<tt>Courier</tt>&#x2019; or &#x2018;<tt>Monospace</tt>&#x2019; as likely possibilities.  Not all computers have the same fonts installed.  It&apos;s a good idea to stick with monospace fonts (ones in which all characters have the same width).</p>",
            "seeAlso": []
          },
          {
            "command": "font",
            "description": "<pre class=\"example\">FONT</pre><p>(wxWidgets only) outputs the name of the font family used in all windows.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  },
  {
    "number": 4,
    "title": "Arithmetic",
    "sections": [
      {
        "number": 4.1,
        "title": "Numeric Operations",
        "commands": [
          {
            "command": "sum",
            "description": "<pre class=\"example\">SUM num1 num2\n(SUM num1 num2 num3 ...)\nnum1 + num2</pre><p>outputs the sum of its inputs.</p>",
            "seeAlso": []
          },
          {
            "command": "difference",
            "description": "<pre class=\"example\">DIFFERENCE num1 num2\nnum1 - num2</pre><p>outputs the difference of its inputs.  Minus sign means infix difference in ambiguous contexts (when preceded by a complete expression), unless it is preceded by a space and followed by a nonspace.  (See also <code>MINUS</code>.)</p>",
            "seeAlso": []
          },
          {
            "command": "minus",
            "description": "<pre class=\"example\">MINUS num\n- num</pre><p>outputs the negative of its input.  Minus sign means unary minus if the previous token is an infix operator or open parenthesis, or it is preceded by a space and followed by a nonspace.  There is a difference in binding strength between the two forms:</p><pre class=\"example\">MINUS 3 + 4     means   -(3+4)\n- 3 + 4         means   (-3)+4</pre>",
            "seeAlso": []
          },
          {
            "command": "product",
            "description": "<pre class=\"example\">PRODUCT num1 num2\n(PRODUCT num1 num2 num3 ...)\nnum1 * num2</pre><p>outputs the product of its inputs.</p>",
            "seeAlso": []
          },
          {
            "command": "quotient",
            "description": "<pre class=\"example\">QUOTIENT num1 num2\n(QUOTIENT num)\nnum1 / num2</pre><p>outputs the quotient of its inputs.  The quotient of two integers is an integer if and only if the dividend is a multiple of the divisor.  (In other words, <tt>QUOTIENT 5 2</tt> is 2.5, not 2, but <tt>QUOTIENT 4 2</tt> is 2, not 2.0 &#x2014; it does the right thing.)  With a single input, <code>QUOTIENT</code> outputs the reciprocal of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "remainder",
            "description": "<pre class=\"example\">REMAINDER num1 num2</pre><p>outputs the remainder on dividing <var>num1</var> by <var>num2</var>; both must be integers and the result is an integer with the same sign as <var>num1</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "modulo",
            "description": "<pre class=\"example\">MODULO num1 num2</pre><p>outputs the remainder on dividing <var>num1</var> by <var>num2</var>; both must be integers and the result is an integer with the same sign as <var>num2</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "int",
            "description": "<pre class=\"example\">INT num</pre><p>outputs its input with fractional part removed, i.e., an integer with the same sign as the input, whose absolute value is the largest integer less than or equal to the absolute value of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "round",
            "description": "<pre class=\"example\">ROUND num</pre><p>outputs the nearest integer to the input.</p>",
            "seeAlso": []
          },
          {
            "command": "sqrt",
            "description": "<pre class=\"example\">SQRT num</pre><p>outputs the square root of the input, which must be nonnegative.</p>",
            "seeAlso": []
          },
          {
            "command": "power",
            "description": "<pre class=\"example\">POWER num1 num2</pre><p>outputs <var>num1</var> to the <var>num2</var> power.  If <var>num1</var> is negative, then <var>num2</var> must be an integer.</p>",
            "seeAlso": []
          },
          {
            "command": "exp",
            "description": "<pre class=\"example\">EXP num</pre><p>outputs <i>e</i> (2.718281828+) to the input power.</p>",
            "seeAlso": []
          },
          {
            "command": "log10",
            "description": "<pre class=\"example\">LOG10 num</pre><p>outputs the common logarithm of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "ln",
            "description": "<pre class=\"example\">LN num</pre><p>outputs the natural logarithm of the input.</p>",
            "seeAlso": []
          },
          {
            "command": "sin",
            "description": "<pre class=\"example\">SIN degrees</pre><p>outputs the sine of its input, which is taken in degrees.</p>",
            "seeAlso": []
          },
          {
            "command": "radsin",
            "description": "<pre class=\"example\">RADSIN radians</pre><p>outputs the sine of its input, which is taken in radians.</p>",
            "seeAlso": []
          },
          {
            "command": "cos",
            "description": "<pre class=\"example\">COS degrees</pre><p>outputs the cosine of its input, which is taken in degrees.</p>",
            "seeAlso": []
          },
          {
            "command": "radcos",
            "description": "<pre class=\"example\">RADCOS radians</pre><p>outputs the cosine of its input, which is taken in radians.</p>",
            "seeAlso": []
          },
          {
            "command": "arctan",
            "description": "<pre class=\"example\">ARCTAN num\n(ARCTAN x y)</pre><p>outputs the arctangent, in degrees, of its input.  With two inputs, outputs the arctangent of y/x, if x is nonzero, or 90 or &#x2013;90 depending on the sign of y, if x is zero.</p>",
            "seeAlso": []
          },
          {
            "command": "radarctan",
            "description": "<pre class=\"example\">RADARCTAN num\n(RADARCTAN x y)</pre><p>outputs the arctangent, in radians, of its input.  With two inputs, outputs the arctangent of y/x, if x is nonzero, or pi/2 or &#x2013;pi/2 depending on the sign of y, if x is zero.</p><p>The expression <tt>2*(RADARCTAN 0 1)</tt> can be used to get the value of pi.</p>",
            "seeAlso": []
          },
          {
            "command": "iseq",
            "description": "<pre class=\"example\">ISEQ from to</pre><p>outputs a list of the integers from <var>from</var> to <var>to</var>, inclusive.</p><pre class=\"example\">? show iseq 3 7\n[3 4 5 6 7]\n? show iseq 7 3\n[7 6 5 4 3]</pre>",
            "seeAlso": []
          },
          {
            "command": "rseq",
            "description": "<pre class=\"example\">RSEQ from to count</pre><p>outputs a list of <var>count</var> equally spaced rational numbers between <var>from</var> and <var>to</var>, inclusive.</p><pre class=\"example\">? show rseq 3 5 9 \n[3 3.25 3.5 3.75 4 4.25 4.5 4.75 5] \n? show rseq 3 5 5\n[3 3.5 4 4.5 5]</pre>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 4.2,
        "title": "Numeric Predicates",
        "commands": [
          {
            "command": "lessp",
            "description": "<pre class=\"example\">LESSP num1 num2\nLESS? num1 num2\nnum1 &lt; num2</pre><p>outputs <code>TRUE</code> if its first input is strictly less than its second.</p>",
            "seeAlso": []
          },
          {
            "command": "greaterp",
            "description": "<pre class=\"example\">GREATERP num1 num2\nGREATER? num1 num2\nnum1 &gt; num2</pre><p>outputs <code>TRUE</code> if its first input is strictly greater than its second.</p>",
            "seeAlso": []
          },
          {
            "command": "lessequalp",
            "description": "<pre class=\"example\">LESSEQUALP num1 num2\nLESSEQUAL? num1 num2\nnum1 &lt;= num2</pre><p>outputs <code>TRUE</code> if its first input is less than or equal to its second.</p>",
            "seeAlso": []
          },
          {
            "command": "greaterequalp",
            "description": "<pre class=\"example\">GREATEREQUALP num1 num2\nGREATEREQUAL? num1 num2\nnum1 &gt;= num2</pre><p>outputs <code>TRUE</code> if its first input is greater than or equal to its second.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 4.3,
        "title": "Random Numbers",
        "commands": [
          {
            "command": "random",
            "description": "<pre class=\"example\">RANDOM num\n(RANDOM start end)</pre><p>with one input, outputs a random nonnegative integer less than its input, which must be a positive integer.</p><p>With two inputs, <code>RANDOM</code> outputs a random integer greater than or equal to the first input, and less than or equal to the second input.  Both inputs must be integers, and the first must be less than the second.  <tt>(RANDOM 0 9)</tt> is equivalent to <tt>RANDOM 10</tt>; <tt>(RANDOM 3 8)</tt> is equivalent to <tt>(RANDOM 6)+3</tt>.</p>",
            "seeAlso": []
          },
          {
            "command": "rerandom",
            "description": "<pre class=\"example\">RERANDOM\n(RERANDOM seed)</pre><p>command.  Makes the results of <code>RANDOM</code> reproducible.  Ordinarily the sequence of random numbers is different each time Logo is used.  If you need the same sequence of pseudo-random numbers repeatedly, e.g. to debug a program, say <code>RERANDOM</code> before the first invocation of <code>RANDOM</code>.  If you need more than one repeatable sequence, you can give <code>RERANDOM</code> an integer input; each possible input selects a unique sequence of numbers.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 4.4,
        "title": "Print Formatting",
        "commands": [
          {
            "command": "form",
            "description": "<pre class=\"example\">FORM num width precision</pre><p>outputs a word containing a printable representation of <var>num</var>, possibly preceded by spaces (and therefore not a number for purposes of performing arithmetic operations), with at least <var>width</var> characters, including exactly <var>precision</var> digits after the decimal point.  (If <var>precision</var> is 0 then there will be no decimal point in the output.)</p><p>As a debugging feature, (<tt>FORM num -1 format</tt>) will print the floating point <var>num</var> according to the C printf <var>format</var>, to allow</p><pre class=\"example\">to hex :num\nop form :num -1 &quot;|%08X %08X|\nend</pre><p>to allow finding out the exact result of floating point operations.  The precise format needed may be machine-dependent.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 4.5,
        "title": "Bitwise Operations",
        "commands": [
          {
            "command": "bitand",
            "description": "<pre class=\"example\">BITAND num1 num2\n(BITAND num1 num2 num3 ...)</pre><p>outputs the bitwise <var>and</var> of its inputs, which must be integers.</p>",
            "seeAlso": [
              "and"
            ]
          },
          {
            "command": "bitor",
            "description": "<pre class=\"example\">BITOR num1 num2\n(BITOR num1 num2 num3 ...)</pre><p>outputs the bitwise <var>or</var> of its inputs, which must be integers.</p>",
            "seeAlso": [
              "or"
            ]
          },
          {
            "command": "bitxor",
            "description": "<pre class=\"example\">BITXOR num1 num2\n(BITXOR num1 num2 num3 ...)</pre><p>outputs the bitwise <var>exclusive or</var> of its inputs, which must be integers.</p>",
            "seeAlso": [
              "or"
            ]
          },
          {
            "command": "bitnot",
            "description": "<pre class=\"example\">BITNOT num</pre><p>outputs the bitwise <var>not</var> of its input, which must be an integer.</p>",
            "seeAlso": [
              "not"
            ]
          },
          {
            "command": "ashift",
            "description": "<pre class=\"example\">ASHIFT num1 num2</pre><p>outputs <var>num1</var> arithmetic-shifted to the left by <var>num2</var> bits.  If <var>num2</var> is negative, the shift is to the right with sign extension.  The inputs must be integers.</p>",
            "seeAlso": []
          },
          {
            "command": "lshift",
            "description": "<pre class=\"example\">LSHIFT num1 num2</pre><p>outputs <var>num1</var> logical-shifted to the left by <var>num2</var> bits.  If <var>num2</var> is negative, the shift is to the right with zero fill.  The inputs must be integers.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  },
  {
    "number": 5,
    "title": "Logical Operations",
    "sections": []
  },
  {
    "number": 6,
    "title": "Graphics",
    "sections": [
      {
        "number": 6.1,
        "title": "Turtle Motion",
        "commands": [
          {
            "command": "forward",
            "description": "<pre class=\"example\">FORWARD dist\nFD dist</pre><p>moves the turtle forward, in the direction that it&apos;s facing, by the specified distance (measured in turtle steps).</p>",
            "seeAlso": []
          },
          {
            "command": "back",
            "description": "<pre class=\"example\">BACK dist\nBK dist</pre><p>moves the turtle backward, i.e., exactly opposite to the direction that it&apos;s facing, by the specified distance.  (The heading of the turtle does not change.)</p>",
            "seeAlso": []
          },
          {
            "command": "left",
            "description": "<pre class=\"example\">LEFT degrees\nLT degrees</pre><p>turns the turtle counterclockwise by the specified angle, measured in degrees (1/360 of a circle).</p>",
            "seeAlso": []
          },
          {
            "command": "right",
            "description": "<pre class=\"example\">RIGHT degrees\nRT degrees</pre><p>turns the turtle clockwise by the specified angle, measured in degrees (1/360 of a circle).</p>",
            "seeAlso": []
          },
          {
            "command": "setpos",
            "description": "<pre class=\"example\">SETPOS pos</pre><p>moves the turtle to an absolute position in the graphics window.  The input is a list of two numbers, the X and Y coordinates.</p>",
            "seeAlso": []
          },
          {
            "command": "setxy",
            "description": "<pre class=\"example\">SETXY xcor ycor</pre><p>moves the turtle to an absolute position in the graphics window.  The two inputs are numbers, the X and Y coordinates.</p>",
            "seeAlso": []
          },
          {
            "command": "setx",
            "description": "<pre class=\"example\">SETX xcor</pre><p>moves the turtle horizontally from its old position to a new absolute horizontal coordinate.  The input is the new X coordinate.</p>",
            "seeAlso": []
          },
          {
            "command": "sety",
            "description": "<pre class=\"example\">SETY ycor</pre><p>moves the turtle vertically from its old position to a new absolute vertical coordinate.  The input is the new Y coordinate.</p>",
            "seeAlso": []
          },
          {
            "command": "setheading",
            "description": "<pre class=\"example\">SETHEADING degrees\nSETH degrees</pre><p>turns the turtle to a new absolute heading.  The input is a number, the heading in degrees clockwise from the positive Y axis.</p>",
            "seeAlso": []
          },
          {
            "command": "home",
            "description": "<pre class=\"example\">HOME</pre><p>moves the turtle to the center of the screen.  Equivalent to  <tt>SETPOS [0 0] SETHEADING 0.</tt></p>",
            "seeAlso": [
              "setpos",
              "setheading"
            ]
          },
          {
            "command": "arc",
            "description": "<pre class=\"example\">ARC angle radius</pre><p>draws an arc of a circle, with the turtle at the center, with the specified radius, starting at the turtle&apos;s heading and extending clockwise through the specified angle.  The turtle does not move.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 6.2,
        "title": "Turtle Motion Queries",
        "commands": [
          {
            "command": "pos",
            "description": "<pre class=\"example\">POS</pre><p>outputs the turtle&apos;s current position, as a list of two numbers, the X and Y coordinates.</p>",
            "seeAlso": []
          },
          {
            "command": "xcor",
            "description": "<pre class=\"example\">XCOR</pre><p>outputs a number, the turtle&apos;s X coordinate.</p>",
            "seeAlso": []
          },
          {
            "command": "ycor",
            "description": "<pre class=\"example\">YCOR</pre><p>outputs a number, the turtle&apos;s Y coordinate.</p>",
            "seeAlso": []
          },
          {
            "command": "heading",
            "description": "<pre class=\"example\">HEADING</pre><p>outputs a number, the turtle&apos;s heading in degrees.</p>",
            "seeAlso": []
          },
          {
            "command": "towards",
            "description": "<pre class=\"example\">TOWARDS pos</pre><p>outputs a number, the heading at which the turtle should be facing so that it would point from its current position to the position given as the input.</p>",
            "seeAlso": []
          },
          {
            "command": "scrunch",
            "description": "<pre class=\"example\">SCRUNCH</pre><p>outputs a list containing two numbers, the X and Y scrunch factors, as used by <code>SETSCRUNCH</code>.  (But note that <code>SETSCRUNCH</code> takes two numbers as inputs, not one list of numbers.)</p>",
            "seeAlso": [
              "setscrunch"
            ]
          }
        ]
      },
      {
        "number": 6.3,
        "title": "Turtle and Window Control",
        "commands": [
          {
            "command": "showturtle",
            "description": "<pre class=\"example\">SHOWTURTLE\nST</pre><p>makes the turtle visible.</p>",
            "seeAlso": []
          },
          {
            "command": "hideturtle",
            "description": "<pre class=\"example\">HIDETURTLE\nHT</pre><p>makes the turtle invisible.  It&apos;s a good idea to do this while you&apos;re in the middle of a complicated drawing, because hiding the turtle speeds up the drawing substantially.</p>",
            "seeAlso": []
          },
          {
            "command": "clean",
            "description": "<pre class=\"example\">CLEAN</pre><p>erases all lines that the turtle has drawn on the graphics window.  The turtle&apos;s state (position, heading, pen mode, etc.) is not changed.</p>",
            "seeAlso": []
          },
          {
            "command": "clearscreen",
            "description": "<pre class=\"example\">CLEARSCREEN\nCS</pre><p>erases the graphics window and sends the turtle to its initial position and heading.  Like <code>HOME</code> and <code>CLEAN</code> together.</p>",
            "seeAlso": [
              "home"
            ]
          },
          {
            "command": "wrap",
            "description": "<pre class=\"example\">WRAP</pre><p>tells the turtle to enter wrap mode:  From now on, if the turtle is asked to move past the boundary of the graphics window, it will &quot;wrap around&quot; and reappear at the opposite edge of the window.  The top edge wraps to the bottom edge, while the left edge wraps to the right edge. (So the window is topologically equivalent to a torus.)  This is the turtle&apos;s initial mode.  Compare <code>WINDOW</code> and <code>FENCE</code>.</p>",
            "seeAlso": [
              "fence"
            ]
          },
          {
            "command": "window",
            "description": "<pre class=\"example\">WINDOW</pre><p>tells the turtle to enter window mode:  From now on, if the turtle is asked to move past the boundary of the graphics window, it will move offscreen.  The visible graphics window is considered as just part of an infinite graphics plane; the turtle can be anywhere on the plane.  (If you lose the turtle, <code>HOME</code> will bring it back to the center of the window.)  Compare <code>WRAP</code> and <code>FENCE</code>.</p>",
            "seeAlso": [
              "home"
            ]
          },
          {
            "command": "fence",
            "description": "<pre class=\"example\">FENCE</pre><p>tells the turtle to enter fence mode:  From now on, if the turtle is asked to move past the boundary of the graphics window, it will move as far as it can and then stop at the edge with an &quot;out of bounds&quot; error message.  Compare <code>WRAP</code> and <code>WINDOW</code>.</p>",
            "seeAlso": [
              "wrap"
            ]
          },
          {
            "command": "fill",
            "description": "<pre class=\"example\">FILL</pre><p>fills in a region of the graphics window containing the turtle and bounded by lines that have been drawn earlier.  This is not portable; it doesn&apos;t work for all machines, and may not work exactly the same way on different machines.</p>",
            "seeAlso": []
          },
          {
            "command": "filled",
            "description": "<pre class=\"example\">FILLED color instructions</pre><p>runs the instructions, remembering all points visited by turtle motion commands, starting <em>and ending</em> with the turtle&apos;s initial position.  Then draws (ignoring penmode) the resulting polygon, in the current pen color, filling the polygon with the given color, which can be a color number or an RGB list.  The instruction list cannot include another FILLED invocation.  (wxWidgets only)</p>",
            "seeAlso": []
          },
          {
            "command": "label",
            "description": "<pre class=\"example\">LABEL text</pre><p>takes a word or list as input, and prints the input on the graphics window, starting at the turtle&apos;s position.</p>",
            "seeAlso": []
          },
          {
            "command": "setlabelheight",
            "description": "<pre class=\"example\">SETLABELHEIGHT height</pre><p>command (wxWidgets only).  Takes a positive integer argument and tries to set the font size so that the character height (including descenders) is that many turtle steps.  This will be different from the number of screen pixels if <code>SETSCRUNCH</code> has been used.  Also, note that <code>SETSCRUNCH</code> changes the font size to try to preserve this height in turtle steps.  Note that the query operation corresponding to this command is <code>LABELSIZE</code>, not <code>LABELHEIGHT</code>, because it tells you the width as well as the height of characters in the current font.</p>",
            "seeAlso": []
          },
          {
            "command": "textscreen",
            "description": "<pre class=\"example\">TEXTSCREEN\nTS</pre><p>rearranges the size and position of windows to maximize the space available in the text window (the window used for interaction with Logo).  The details differ among machines.  Compare <code>SPLITSCREEN</code> and <code>FULLSCREEN</code>.</p>",
            "seeAlso": [
              "splitscreen"
            ]
          },
          {
            "command": "fullscreen",
            "description": "<pre class=\"example\">FULLSCREEN\nFS</pre><p>rearranges the size and position of windows to maximize the space available in the graphics window.  The details differ among machines. Compare <code>SPLITSCREEN</code> and <code>TEXTSCREEN</code>.</p><p>Since there must be a text window to allow printing (including the printing of the Logo prompt), Logo automatically switches from fullscreen to splitscreen whenever anything is printed.</p><p>In the DOS version, switching from fullscreen to splitscreen loses the part of the picture that&apos;s hidden by the text window.  [This design decision follows from the scarcity of memory, so that the extra memory to remember an invisible part of a drawing seems too expensive.]</p>",
            "seeAlso": []
          },
          {
            "command": "splitscreen",
            "description": "<pre class=\"example\">SPLITSCREEN\nSS</pre><p>rearranges the size and position of windows to allow some room for text interaction while also keeping most of the graphics window visible.  The details differ among machines.  Compare <code>TEXTSCREEN</code> and <code>FULLSCREEN</code>.</p>",
            "seeAlso": [
              "textscreen"
            ]
          },
          {
            "command": "setscrunch",
            "description": "<pre class=\"example\">SETSCRUNCH xscale yscale</pre><p>adjusts the aspect ratio and scaling of the graphics display.  After this command is used, all further turtle motion will be adjusted by multiplying the horizontal and vertical extent of the motion by the two numbers given as inputs.  For example, after the instruction <tt>SETSCRUNCH 2 1</tt> motion at a heading of 45 degrees will move twice as far horizontally as vertically.  If your squares don&apos;t come out square, try this.  (Alternatively, you can deliberately misadjust the aspect ratio to draw an ellipse.)</p><p>For all modern computers, both scale factors are initially 1. For DOS machines, the scale factors are initially set according to what the hardware claims the aspect ratio is, but the hardware sometimes lies.  For DOS, the values set by <code>SETSCRUNCH</code> are remembered in a file (called &#x2018;<tt>scrunch.dat</tt>&#x2019;) and are automatically put into effect when a Logo session begins.</p>",
            "seeAlso": []
          },
          {
            "command": "refresh",
            "description": "<pre class=\"example\">REFRESH</pre><p>(command) tells Logo to remember the turtle&apos;s motions so that they can be used for high-resolution printing (wxWidgets) or to refresh the graphics window if it is moved, resized, or overlayed (non-wxWidgets).  This is the default.</p>",
            "seeAlso": []
          },
          {
            "command": "norefresh",
            "description": "<pre class=\"example\">NOREFRESH</pre><p>(command) tells Logo not to remember the turtle&apos;s motions, which may be useful to save time and memory if your program is interactive or animated, rather than drawing a static picture you&apos;ll want to print later (wxWidgets).  In non-wxWidgets versions, using NOREFRESH may prevent Logo from restoring the graphics image after the window is moved, resized, or overlayed.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 6.4,
        "title": "Turtle and Window Queries",
        "commands": [
          {
            "command": "shownp",
            "description": "<pre class=\"example\">SHOWNP\nSHOWN?</pre><p>outputs <code>TRUE</code> if the turtle is shown (visible), <code>FALSE</code> if the turtle is hidden.  See <code>SHOWTURTLE</code> and <code>HIDETURTLE</code>.</p>",
            "seeAlso": [
              "showturtle",
              "hideturtle"
            ]
          },
          {
            "command": "screenmode",
            "description": "<pre class=\"example\">SCREENMODE</pre><p>outputs the word <code>TEXTSCREEN</code>, <code>SPLITSCREEN</code>, or <code>FULLSCREEN</code> depending on the current screen mode.</p>",
            "seeAlso": []
          },
          {
            "command": "turtlemode",
            "description": "<pre class=\"example\">TURTLEMODE</pre><p>outputs the word <code>WRAP</code>, <code>FENCE</code>, or <code>WINDOW</code> depending on the current turtle mode.</p>",
            "seeAlso": []
          },
          {
            "command": "labelsize",
            "description": "<pre class=\"example\">LABELSIZE</pre><p>(wxWidgets only) outputs a list of two positive integers, the width and height of characters displayed by <code>LABEL</code> measured in turtle steps (which will be different from screen pixels if <code>SETSCRUNCH</code> has been used).  There is no <code>SETLABELSIZE</code> because the width and height of a font are not separately controllable, so the inverse of this operation is <code>SETLABELHEIGHT</code>, which takes just one number for the desired height.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 6.5,
        "title": "Pen and Background Control",
        "commands": [
          {
            "command": "pendown",
            "description": "<pre class=\"example\">PENDOWN\nPD</pre><p>sets the pen&apos;s position to <code>DOWN</code>, without changing its mode.</p>",
            "seeAlso": []
          },
          {
            "command": "penup",
            "description": "<pre class=\"example\">PENUP\nPU</pre><p>sets the pen&apos;s position to <code>UP</code>, without changing its mode.</p>",
            "seeAlso": []
          },
          {
            "command": "penpaint",
            "description": "<pre class=\"example\">PENPAINT\nPPT</pre><p>sets the pen&apos;s position to <code>DOWN</code> and mode to <code>PAINT</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "penerase",
            "description": "<pre class=\"example\">PENERASE\nPE</pre><p>sets the pen&apos;s position to <code>DOWN</code> and mode to <code>ERASE</code>.</p>",
            "seeAlso": [
              "erase"
            ]
          },
          {
            "command": "penreverse",
            "description": "<pre class=\"example\">PENREVERSE\nPX</pre><p>sets the pen&apos;s position to <code>DOWN</code> and mode to <code>REVERSE</code>.  (This may interact in system-dependent ways with use of color.)</p>",
            "seeAlso": [
              "reverse"
            ]
          },
          {
            "command": "setpencolor",
            "description": "<pre class=\"example\">SETPENCOLOR colornumber.or.rgblist\nSETPC colornumber.or.rgblist</pre><p>sets the pen color to the given number, which must be a nonnegative integer.  There are initial assignments for the first 16 colors:</p><pre class=\"example\"> 0  black\t 1  blue\t 2  green\t 3  cyan\n 4  red\t\t 5  magenta\t 6  yellow\t 7 white\n 8  brown\t 9  tan\t\t10  forest\t11  aqua\n12  salmon\t13  purple\t14  orange\t15  grey</pre><p>but other colors can be assigned to numbers by the <code>PALETTE</code> command. Alternatively, sets the pen color to the given RGB values (a list of three nonnegative numbers less than 100 specifying the percent saturation of red, green, and blue in the desired color).</p>",
            "seeAlso": []
          },
          {
            "command": "setpalette",
            "description": "<pre class=\"example\">SETPALETTE colornumber rgblist</pre><p>sets the actual color corresponding to a given number, if allowed by the hardware and operating system.  Colornumber must be an integer greater than or equal to 8.  (Logo tries to keep the first 8 colors constant.)  The second input is a list of three nonnegative numbers less than 100 specifying the percent saturation of red, green, and blue in the desired color.</p>",
            "seeAlso": []
          },
          {
            "command": "setpensize",
            "description": "<pre class=\"example\">SETPENSIZE size</pre><p>sets the thickness of the pen.  The input is either a single positive integer or a list of two positive integers (for horizontal and vertical thickness).  Some versions pay no attention to the second number, but always have a square pen.</p>",
            "seeAlso": []
          },
          {
            "command": "setpenpattern",
            "description": "<pre class=\"example\">SETPENPATTERN pattern</pre><p>sets hardware-dependent pen characteristics.  This command is not guaranteed compatible between implementations on different machines.</p>",
            "seeAlso": []
          },
          {
            "command": "setpen",
            "description": "<pre class=\"example\">SETPEN list</pre><p>sets the pen&apos;s position, mode, thickness, and hardware-dependent characteristics according to the information in the input list, which should be taken from an earlier invocation of <code>PEN</code>.</p>",
            "seeAlso": [
              "pen"
            ]
          },
          {
            "command": "setbackground",
            "description": "<pre class=\"example\">SETBACKGROUND colornumber.or.rgblist\nSETBG colornumber.or.rgblist</pre><p>set the screen background color by slot number or RGB values. See <code>SETPENCOLOR</code> for details.</p>",
            "seeAlso": [
              "setpencolor"
            ]
          }
        ]
      },
      {
        "number": 6.6,
        "title": "Pen Queries",
        "commands": [
          {
            "command": "pendownp",
            "description": "<pre class=\"example\">PENDOWNP\nPENDOWN?</pre><p>outputs <code>TRUE</code> if the pen is down, <code>FALSE</code> if it&apos;s up.</p>",
            "seeAlso": []
          },
          {
            "command": "penmode",
            "description": "<pre class=\"example\">PENMODE</pre><p>outputs one of the words <code>PAINT</code>, <code>ERASE</code>, or <code>REVERSE</code> according to the current pen mode.</p>",
            "seeAlso": [
              "erase",
              "reverse"
            ]
          },
          {
            "command": "pencolor",
            "description": "<pre class=\"example\">PENCOLOR\nPC</pre><p>outputs a color number, a nonnegative integer that is associated with a particular color, or a list of RGB values if such a list was used as the most recent input to <code>SETPENCOLOR</code>.  There are initial assignments for the first 16 colors:</p><pre class=\"example\"> 0  black        1  blue         2  green        3  cyan\n 4  red          5  magenta      6  yellow       7 white\n 8  brown        9  tan         10  forest      11  aqua\n12  salmon      13  purple      14  orange      15  grey</pre><p>but other colors can be assigned to numbers by the <code>PALETTE</code> command.</p>",
            "seeAlso": []
          },
          {
            "command": "palette",
            "description": "<pre class=\"example\">PALETTE colornumber</pre><p>outputs a list of three nonnegative numbers less than 100 specifying the percent saturation of red, green, and blue in the color associated with the given number.</p>",
            "seeAlso": []
          },
          {
            "command": "pensize",
            "description": "<pre class=\"example\">PENSIZE</pre><p>outputs a list of two positive integers, specifying the horizontal and vertical thickness of the turtle pen.  (In some implementations, including wxWidgets, the two numbers are always equal.)</p><pre class=\"example\">PENPATTERN</pre><p>outputs system-specific pen information.</p>",
            "seeAlso": []
          },
          {
            "command": "pen",
            "description": "<pre class=\"example\">PEN</pre><p>outputs a list containing the pen&apos;s position, mode, thickness, and hardware-specific characteristics, for use by <code>SETPEN</code>.</p>",
            "seeAlso": [
              "setpen"
            ]
          },
          {
            "command": "background",
            "description": "<pre class=\"example\">BACKGROUND\nBG</pre><p>outputs the graphics background color, either as a slot number or as an RGB list, whichever way it was set.  (See <code>PENCOLOR</code>.)</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 6.7,
        "title": "Saving and Loading Pictures",
        "commands": [
          {
            "command": "savepict",
            "description": "<pre class=\"example\">SAVEPICT filename</pre><p>command.  Writes a file with the specified name containing the state of the graphics window, including any nonstandard color palette settings, in Logo&apos;s internal format.  This picture can be restored to the screen using <code>LOADPICT</code>.  The format is not portable between platforms, nor is it readable by other programs.  <a href=\"#SEC225\">epspict</a> to export Logo graphics for other programs.</p>",
            "seeAlso": []
          },
          {
            "command": "loadpict",
            "description": "<pre class=\"example\">LOADPICT filename</pre><p>command.  Reads the specified file, which must have been written by a <code>SAVEPICT</code> command, and restores the graphics window and color palette settings to the values stored in the file.  Any drawing previously on the screen is cleared.</p>",
            "seeAlso": [
              "savepict"
            ]
          },
          {
            "command": "epspict",
            "description": "<pre class=\"example\">EPSPICT filename</pre><p>command.  Writes a file with the specified name, containing an Encapsulated Postscript (EPS) representation of the state of the graphics window.  This file can be imported into other programs that understand EPS format.  Restrictions: the drawing cannot use <code>FILL</code>, <code>PENERASE</code>, or <code>PENREVERSE</code>; any such instructions will be ignored in the translation to Postscript form.</p>",
            "seeAlso": [
              "fill",
              "penerase",
              "penreverse"
            ]
          }
        ]
      },
      {
        "number": 6.8,
        "title": "Mouse Queries",
        "commands": [
          {
            "command": "mousepos",
            "description": "<pre class=\"example\">MOUSEPOS</pre><p>outputs the coordinates of the mouse, provided that it&apos;s within the graphics window, in turtle coordinates.  If the mouse is outside the graphics window, then the last position within the window is returned. Exception:  If a mouse button is pressed within the graphics window and held while the mouse is dragged outside the window, the mouse&apos;s position is returned as if the window were big enough to include it.</p>",
            "seeAlso": []
          },
          {
            "command": "clickpos",
            "description": "<pre class=\"example\">CLICKPOS</pre><p>outputs the coordinates that the mouse was at when a mouse button was most recently pushed, provided that that position was within the graphics window, in turtle coordinates.  (wxWidgets only)</p>",
            "seeAlso": []
          },
          {
            "command": "buttonp",
            "description": "<pre class=\"example\">BUTTONP\nBUTTON?</pre><p>outputs <code>TRUE</code> if a mouse button is down and the mouse is over the graphics window.  Once the button is down, <code>BUTTONP</code> remains true until the button is released, even if the mouse is dragged out of the graphics window.</p>",
            "seeAlso": []
          },
          {
            "command": "button",
            "description": "<pre class=\"example\">BUTTON</pre><p>outputs 0 if no mouse button has been pushed inside the Logo window since the last call to <code>BUTTON</code>.  Otherwise, it outputs an integer between 1 and 3 indicating which button was most recently pressed. Ordinarily 1 means left, 2 means right, and 3 means center, but operating systems may reconfigure these.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  },
  {
    "number": 7,
    "title": "Workspace Management",
    "sections": [
      {
        "number": 7.1,
        "title": "Procedure Definition",
        "commands": [
          {
            "command": "to",
            "description": "<pre class=\"example\">TO procname :input1 :input2 ...\t\t\t(special form)</pre><p>command.  Prepares Logo to accept a procedure definition.  The procedure will be named <var>procname</var> and there must not already be a procedure by that name.  The inputs will be called <var>input1</var> etc.  Any number of inputs are allowed, including none.  Names of procedures and inputs are case-insensitive.</p><p>Unlike every other Logo procedure, TO takes as its inputs the actual words typed in the instruction line, as if they were all quoted, rather than the results of evaluating expressions to provide the inputs. (That&apos;s what <em>special form</em> means.)</p><p>This version of Logo allows variable numbers of inputs to a procedure. After the procedure name come four kinds of things, <em>in this order</em>:</p><pre class=\"example\">    1.   0 or more REQUIRED inputs    :FOO :FROBOZZ\n    2.   0 or more OPTIONAL inputs    [:BAZ 87] [:THINGO 5+9]\n    3.   0 or 1 REST input            [:GARPLY]\n    4.   0 or 1 DEFAULT number        5</pre><p>Every procedure has a <var>minimum</var>, <var>default</var>, and <var>maximum</var> number of inputs. (The latter can be infinite.)</p><p>The <var>minimum</var> number of inputs is the number of required inputs, which must come first.  A required input is indicated by the</p><pre class=\"example\">:inputname</pre><p>notation.</p><p>After all the required inputs can be zero or more optional inputs, each of which is represented by the following notation:</p><pre class=\"example\">[:inputname default.value.expression]</pre><p>When the procedure is invoked, if actual inputs are not supplied for these optional inputs, the <var>default value expression</var>s are evaluated to set values for the corresponding input names.  The inputs are processed from left to right, so a default value expression can be based on earlier inputs.  Example:</p><pre class=\"example\">to proc :inlist [:startvalue first :inlist]</pre><p>If the procedure is invoked by saying</p><pre class=\"example\">proc [a b c]</pre><p>then the variable <code>inlist</code> will have the value <tt>[A B C]</tt> and the variable <code>startvalue</code> will have the value <tt>A</tt>.  If the procedure is invoked by saying</p><pre class=\"example\">(proc [a b c] &quot;x)</pre><p>then <code>inlist</code> will have the value <tt>[A B C]</tt> and <code>startvalue</code> will have the value <tt>X</tt>.</p><p>After all the required and optional input can come a single <em>rest</em> input, represented by the following notation:</p><pre class=\"example\">[:inputname]</pre><p>This is a rest input rather than an optional input because there is no default value expression.  There can be at most one rest input.  When the procedure is invoked, the value of this <var>inputname</var> will be a list containing all of the actual inputs provided that were not used for required or optional inputs.  Example:</p><pre class=\"example\">to proc :in1 [:in2 &quot;foo] [:in3 &quot;baz] [:in4]</pre><p>If this procedure is invoked by saying</p><pre class=\"example\">proc &quot;x</pre><p>then <code>in1</code> has the value <tt>X</tt>, <code>in2</code> has the value <tt>FOO</tt>, <code>in3</code> has the value <tt>BAZ</tt>, and <code>in4</code> has the value <tt>[]</tt> (the empty list).  If it&apos;s invoked by saying</p><pre class=\"example\">(proc &quot;a &quot;b &quot;c &quot;d &quot;e)</pre><p>then <code>in1</code> has the value <tt>A</tt>, <code>in2</code> has the value <tt>B</tt>, <code>in3</code> has the value <tt>C</tt>, and <code>in4</code> has the value <tt>[D E]</tt>.</p><p>The <em>maximum</em> number of inputs for a procedure is infinite if a rest input is given; otherwise, it is the number of required inputs plus the number of optional inputs.</p><p>The <em>default</em> number of inputs for a procedure, which is the number of inputs that it will accept if its invocation is not enclosed in parentheses, is ordinarily equal to the minimum number.  If you want a different default number you can indicate that by putting the desired default number as the last thing on the <code>TO</code> line.  example:</p><pre class=\"example\">to proc :in1 [:in2 &quot;foo] [:in3] 3</pre><p>This procedure has a minimum of one input, a default of three inputs, and an infinite maximum.</p><p>Logo responds to the <code>TO</code> command by entering procedure definition mode. The prompt character changes from <code>?</code> to <code>&gt;</code> and whatever instructions you type become part of the definition until you type a line containing only the word <code>END</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "define",
            "description": "<pre class=\"example\">DEFINE procname text</pre><p>command.  Defines a procedure with name <var>procname</var> and text <var>text</var>.  If there is already a procedure with the same name, the new definition replaces the old one.  The <var>text</var> input must be a list whose members are lists.  The first member is a list of inputs; it looks like a <code>TO</code> line but without the word <code>TO</code>, without the procedure name, and without the colons before input names.  In other words, the members of this first sublist are words for the names of required inputs and lists for the names of optional or rest inputs.  The remaining sublists of the <var>text</var> input make up the body of the procedure, with one sublist for each instruction line of the body.  (There is no <code>END</code> line in the text input.) It is an error to redefine a primitive procedure unless the variable <code>REDEFP</code> has the value <code>TRUE</code>.</p>",
            "seeAlso": [
              "redefp"
            ]
          },
          {
            "command": "text",
            "description": "<pre class=\"example\">TEXT procname</pre><p>outputs the text of the procedure named <var>procname</var> in the form expected by <code>DEFINE</code>: a list of lists, the first of which describes the inputs to the procedure and the rest of which are the lines of its body.  The text does not reflect formatting information used when the procedure was defined, such as continuation lines and extra spaces.</p>",
            "seeAlso": []
          },
          {
            "command": "fulltext",
            "description": "<pre class=\"example\">FULLTEXT procname</pre><p>outputs a representation of the procedure <var>procname</var> in which formatting information is preserved.  If the procedure was defined with <code>TO</code>, <code>EDIT</code>, or <code>LOAD</code>, then the output is a list of words.  Each word represents one entire line of the definition in the form output by <code>READWORD</code>, including extra spaces and continuation lines.  The last member of the output represents the <code>END</code> line.  If the procedure was defined with <code>DEFINE</code>, then the output is a list of lists.  If these lists are printed, one per line, the result will look like a definition using <code>TO</code>.  Note: the output from <code>FULLTEXT</code> is not suitable for use as input to <code>DEFINE</code>!</p>",
            "seeAlso": [
              "to",
              "edit",
              "load",
              "define"
            ]
          },
          {
            "command": "copydef",
            "description": "<pre class=\"example\">COPYDEF newname oldname</pre><p>command.  Makes <var>newname</var> a procedure identical to <var>oldname</var>.  The latter may be a primitive.  If <var>newname</var> was already defined, its previous definition is lost.  If <var>newname</var> was already a primitive, the redefinition is not permitted unless the variable <code>REDEFP</code> has the value <code>TRUE</code>.</p><p>Note: dialects of Logo differ as to the order of inputs to <code>COPYDEF</code>. This dialect uses &quot;<code>MAKE</code> order,&quot; not &quot;<code>NAME</code> order.&quot;</p>",
            "seeAlso": [
              "redefp",
              "save",
              "po",
              "pot"
            ]
          }
        ]
      },
      {
        "number": 7.2,
        "title": "Variable Definition",
        "commands": [
          {
            "command": "make",
            "description": "<pre class=\"example\">MAKE varname value</pre><p>command.  Assigns the value <var>value</var> to the variable named <var>varname</var>, which must be a word.  Variable names are case-insensitive.  If a variable with the same name already exists, the value of that variable is changed.  If not, a new global variable is created.</p>",
            "seeAlso": []
          },
          {
            "command": "name",
            "description": "<pre class=\"example\">NAME value varname</pre><p>command.  Same as <code>MAKE</code> but with the inputs in reverse order.</p>",
            "seeAlso": []
          },
          {
            "command": "local",
            "description": "<pre class=\"example\">LOCAL varname\nLOCAL varnamelist\n(LOCAL varname1 varname2 ...)</pre><p>command.  Accepts as inputs one or more words, or a list of words.  A variable is created for each of these words, with that word as its name. The variables are local to the currently running procedure.  Logo variables follow dynamic scope rules; a variable that is local to a procedure is available to any subprocedure invoked by that procedure. The variables created by <code>LOCAL</code> have no initial value; they must be assigned a value (e.g., with <code>MAKE</code>) before the procedure attempts to read their value.</p>",
            "seeAlso": [
              "make"
            ]
          },
          {
            "command": "localmake",
            "description": "<pre class=\"example\">LOCALMAKE varname value</pre><p>command.  Makes the named variable local, like <code>LOCAL</code>, and assigns it the given value, like <code>MAKE</code>.</p>",
            "seeAlso": [
              "local",
              "make"
            ]
          },
          {
            "command": "thing",
            "description": "<pre class=\"example\">THING varname\n:quoted.varname</pre><p>outputs the value of the variable whose name is the input.  If there is more than one such variable, the innermost local variable of that name is chosen.  The colon notation is an abbreviation not for <code>THING</code> but for the combination</p><pre class=\"example\">thing &quot;</pre><p>so that <tt>:FOO</tt> means <tt>THING &quot;FOO</tt>.</p>",
            "seeAlso": []
          },
          {
            "command": "global",
            "description": "<pre class=\"example\">GLOBAL varname\nGLOBAL varnamelist\n(GLOBAL varname1 varname2 ...)</pre><p>command.  Accepts as inputs one or more words, or a list of words.  A global variable is created for each of these words, with that word as its name.  The only reason this is necessary is that you might want to use the &quot;setter&quot; notation <code>SETXYZ</code> for a variable <code>XYZ</code> that does not already have a value; <tt>GLOBAL &quot;XYZ</tt> makes that legal. Note: If there is currently a local variable of the same name, this command does *not* make Logo use the global value instead of the local one.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 7.3,
        "title": "Property Lists",
        "commands": [
          {
            "command": "pprop",
            "description": "<pre class=\"example\">PPROP plistname propname value</pre><p>command.  Adds a property to the <var>plistname</var> property list with name <var>propname</var> and value <var>value</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "gprop",
            "description": "<pre class=\"example\">GPROP plistname propname</pre><p>outputs the value of the <var>propname</var> property in the <var>plistname</var> property list, or the empty list if there is no such property.</p>",
            "seeAlso": []
          },
          {
            "command": "remprop",
            "description": "<pre class=\"example\">REMPROP plistname propname</pre><p>command.  Removes the property named <var>propname</var> from the property list named <var>plistname</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "plist",
            "description": "<pre class=\"example\">PLIST plistname</pre><p>outputs a list whose odd-numbered members are the names, and whose even-numbered members are the values, of the properties in the property list named <var>plistname</var>.  The output is a copy of the actual property list; changing properties later will not magically change a list output earlier by <code>PLIST</code>.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 7.4,
        "title": "Workspace Predicates",
        "commands": [
          {
            "command": "procedurep",
            "description": "<pre class=\"example\">PROCEDUREP name\nPROCEDURE? name</pre><p>outputs <code>TRUE</code> if the input is the name of a procedure.</p>",
            "seeAlso": []
          },
          {
            "command": "primitivep",
            "description": "<pre class=\"example\">PRIMITIVEP name\nPRIMITIVE? name</pre><p>outputs <code>TRUE</code> if the input is the name of a primitive procedure (one built into Logo).  Note that some of the procedures described in this document are library procedures, not primitives.</p>",
            "seeAlso": []
          },
          {
            "command": "definedp",
            "description": "<pre class=\"example\">DEFINEDP name\nDEFINED? name</pre><p>outputs <code>TRUE</code> if the input is the name of a user-defined procedure, including a library procedure.</p>",
            "seeAlso": []
          },
          {
            "command": "namep",
            "description": "<pre class=\"example\">NAMEP name\nNAME? name</pre><p>outputs <code>TRUE</code> if the input is the name of a variable.</p>",
            "seeAlso": []
          },
          {
            "command": "plistp",
            "description": "<pre class=\"example\">PLISTP name\nPLIST? name</pre><p>outputs <code>TRUE</code> if the input is the name of a <em>nonempty</em> property list. (In principle every word is the name of a property list; if you haven&apos;t put any properties in it, <code>PLIST</code> of that name outputs an empty list, rather than giving an error message.)</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 7.5,
        "title": "Workspace Queries",
        "commands": [
          {
            "command": "contents",
            "description": "<pre class=\"example\">CONTENTS</pre><p>outputs a &quot;contents list,&quot; i.e., a list of three lists containing names of defined procedures, variables, and property lists respectively.  This list includes all unburied named items in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "buried",
            "description": "<pre class=\"example\">BURIED</pre><p>outputs a contents list including all buried named items in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "traced",
            "description": "<pre class=\"example\">TRACED</pre><p>outputs a contents list including all traced named items in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "stepped",
            "description": "<pre class=\"example\">STEPPED</pre><p>outputs a contents list including all stepped named items in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "procedures",
            "description": "<pre class=\"example\">PROCEDURES</pre><p>outputs a list of the names of all unburied user-defined procedures in the workspace.  Note that this is a list of names, not a contents list. (However, procedures that require a contents list as input will accept this list.)</p>",
            "seeAlso": []
          },
          {
            "command": "primitives",
            "description": "<pre class=\"example\">PRIMITIVES</pre><p>outputs a list of the names of all primitive procedures in the workspace.  Note that this is a list of names, not a contents list.  (However, procedures that require a contents list as input will accept this list.)</p>",
            "seeAlso": []
          },
          {
            "command": "names",
            "description": "<pre class=\"example\">NAMES</pre><p>outputs a contents list consisting of an empty list (indicating no procedure names) followed by a list of all unburied variable names in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "plists",
            "description": "<pre class=\"example\">PLISTS</pre><p>outputs a contents list consisting of two empty lists (indicating no procedures or variables) followed by a list of all unburied nonempty property lists in the workspace.</p>",
            "seeAlso": []
          },
          {
            "command": "namelist",
            "description": "<pre class=\"example\">NAMELIST varname\nNAMELIST varnamelist</pre><p>outputs a contents list consisting of an empty list followed by a list of the name or names given as input.  This is useful in conjunction with workspace control procedures that require a contents list as input.</p>",
            "seeAlso": []
          },
          {
            "command": "pllist",
            "description": "<pre class=\"example\">PLLIST plname\nPLLIST plnamelist</pre><p>outputs a contents list consisting of two empty lists followed by a list of the name or names given as input.  This is useful in conjunction with workspace control procedures that require a contents list as input.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "arity",
            "description": "<pre class=\"example\">ARITY procedurename</pre><p>outputs a list of three numbers: the minimum, default, and maximum number of inputs for the procedure whose name is the input.  It is an error if there is no such procedure.  A maximum of -1 means that the number of inputs is unlimited.</p>",
            "seeAlso": []
          },
          {
            "command": "nodes",
            "description": "<pre class=\"example\">NODES</pre><p>outputs a list of two numbers.  The first represents the number of nodes of memory currently in use.  The second shows the maximum number of nodes that have been in use at any time since the last invocation of <code>NODES</code>.  (A node is a small block of computer memory as used by Logo. Each number uses one node.  Each non-numeric word uses one node, plus some non-node memory for the characters in the word.  Each array takes one node, plus some non-node memory, as well as the memory required by its elements.  Each list requires one node per element, as well as the memory within the elements.)  If you want to track the memory use of an algorithm, it is best if you invoke <code>GC</code> at the beginning of each iteration, since otherwise the maximum will include storage that is unused but not yet collected.</p>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 7.6,
        "title": "Workspace Inspection",
        "commands": [
          {
            "command": "po",
            "description": "<pre class=\"example\">PRINTOUT contentslist\nPO contentslist</pre><p>command.  Prints to the write stream the definitions of all procedures, variables, and property lists named in the input contents list.</p>",
            "seeAlso": []
          },
          {
            "command": "poall",
            "description": "<pre class=\"example\">POALL</pre><p>command.  Prints all unburied definitions in the workspace.  Abbreviates <tt>PO CONTENTS</tt>.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "pops",
            "description": "<pre class=\"example\">POPS</pre><p>command.  Prints the definitions of all unburied procedures in the workspace.  Abbreviates <tt>PO PROCEDURES</tt>.</p>",
            "seeAlso": [
              "po",
              "procedures"
            ]
          },
          {
            "command": "pons",
            "description": "<pre class=\"example\">PONS</pre><p>command.  Prints the definitions of all unburied variables in the workspace.  Abbreviates <tt>PO NAMES</tt>.</p>",
            "seeAlso": [
              "po",
              "names"
            ]
          },
          {
            "command": "popls",
            "description": "<pre class=\"example\">POPLS</pre><p>command.  Prints the contents of all unburied nonempty property lists in the workspace.  Abbreviates <tt>PO PLISTS</tt>.</p>",
            "seeAlso": [
              "po",
              "plists"
            ]
          },
          {
            "command": "pon",
            "description": "<pre class=\"example\">PON varname\nPON varnamelist</pre><p>command.  Prints the definitions of the named variable(s).   <br> Abbreviates <tt>PO NAMELIST varname(list)</tt>.</p>",
            "seeAlso": [
              "po",
              "namelist"
            ]
          },
          {
            "command": "popl",
            "description": "<pre class=\"example\">POPL plname\nPOPL plnamelist</pre><p>command.  Prints the definitions of the named property list(s). <br> Abbreviates <tt>PO PLLIST plname(list)</tt>.</p>",
            "seeAlso": [
              "po",
              "pllist"
            ]
          },
          {
            "command": "pot",
            "description": "<pre class=\"example\">POT contentslist</pre><p>command.  Prints the title lines of the named procedures and the definitions of the named variables and property lists.  For property lists, the entire list is shown on one line instead of as a series of <code>PPROP</code> instructions as in <code>PO</code>.</p>",
            "seeAlso": [
              "pprop",
              "po"
            ]
          },
          {
            "command": "pots",
            "description": "<pre class=\"example\">POTS</pre><p>command.  Prints the title lines of all unburied procedures in the workspace.  Abbreviates <tt>POT PROCEDURES</tt>.</p>",
            "seeAlso": [
              "procedures"
            ]
          }
        ]
      },
      {
        "number": 7.7,
        "title": "Workspace Control",
        "commands": [
          {
            "command": "erase",
            "description": "<pre class=\"example\">ERASE contentslist\nER contentslist</pre><p>command.  Erases from the workspace the procedures, variables, and property lists named in the input.  Primitive procedures may not be erased unless the variable <code>REDEFP</code> has the value <code>TRUE</code>.</p>",
            "seeAlso": [
              "redefp"
            ]
          },
          {
            "command": "erall",
            "description": "<pre class=\"example\">ERALL</pre><p>command.  Erases all unburied procedures, variables, and property lists from the workspace.  Abbreviates <tt>ERASE CONTENTS</tt>.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "erps",
            "description": "<pre class=\"example\">ERPS</pre><p>command.  Erases all unburied procedures from the workspace. <br> Abbreviates <tt>ERASE PROCEDURES</tt>.</p>",
            "seeAlso": [
              "erase",
              "procedures"
            ]
          },
          {
            "command": "erns",
            "description": "<pre class=\"example\">ERNS</pre><p>command.  Erases all unburied variables from the workspace.  Abbreviates <tt>ERASE NAMES</tt>.</p>",
            "seeAlso": [
              "erase",
              "names"
            ]
          },
          {
            "command": "erpls",
            "description": "<pre class=\"example\">ERPLS</pre><p>command.  Erases all unburied property lists from the workspace. <br> Abbreviates <tt>ERASE PLISTS</tt>.</p>",
            "seeAlso": [
              "erase",
              "plists"
            ]
          },
          {
            "command": "ern",
            "description": "<pre class=\"example\">ERN varname\nERN varnamelist</pre><p>command.  Erases from the workspace the variable(s) named in the input. Abbreviates <tt>ERASE NAMELIST <var>varname(list)</var></tt>.</p>",
            "seeAlso": [
              "erase",
              "namelist"
            ]
          },
          {
            "command": "erpl",
            "description": "<pre class=\"example\">ERPL plname\nERPL plnamelist</pre><p>command.  Erases from the workspace the property list(s) named in the input.  Abbreviates <tt>ERASE PLLIST <var>plname(list)</var></tt>.</p>",
            "seeAlso": [
              "erase",
              "pllist"
            ]
          },
          {
            "command": "bury",
            "description": "<pre class=\"example\">BURY contentslist</pre><p>command.  Buries the procedures, variables, and property lists named in the input.  A buried item is not included in the lists output by <code>CONTENTS</code>, <code>PROCEDURES</code>, <code>VARIABLES</code>, and <code>PLISTS</code>, but is included in the list output by <code>BURIED</code>.  By implication, buried things are not printed by <code>POALL</code> or saved by <code>SAVE</code>.</p>",
            "seeAlso": [
              "contents",
              "procedures",
              "pons",
              "plists",
              "poall",
              "save"
            ]
          },
          {
            "command": "buryall",
            "description": "<pre class=\"example\">BURYALL</pre><p>command.  Abbreviates <tt>BURY CONTENTS</tt>.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "buryname",
            "description": "<pre class=\"example\">BURYNAME varname\nBURYNAME varnamelist</pre><p>command.  Abbreviates <tt>BURY NAMELIST <code>varname(list)</code></tt>.</p>",
            "seeAlso": [
              "bury",
              "namelist"
            ]
          },
          {
            "command": "unbury",
            "description": "<pre class=\"example\">UNBURY contentslist</pre><p>command.  Unburies the procedures, variables, and property lists named in the input.  That is, the named items will be returned to view in <code>CONTENTS</code>, etc.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "unburyall",
            "description": "<pre class=\"example\">UNBURYALL</pre><p>command.  Abbreviates <tt>UNBURY BURIED</tt>.</p>",
            "seeAlso": [
              "buried"
            ]
          },
          {
            "command": "unburyname",
            "description": "<pre class=\"example\">UNBURYNAME varname\nUNBURYNAME varnamelist</pre><p>command.  Abbreviates <tt>UNBURY NAMELIST <var>varname(list)</var></tt>.</p>",
            "seeAlso": [
              "unbury",
              "namelist"
            ]
          },
          {
            "command": "buriedp",
            "description": "<pre class=\"example\">BURIEDP contentslist\nBURIED? contentslist</pre><p>outputs <code>TRUE</code> if the first procedure, variable, or property list named in the contents list is buried, <code>FALSE</code> if not.  Only the first thing in the list is tested; the most common use will be with a word as input, naming a procedure, but a contents list is allowed so that you can <code>BURIEDP [[] [<var>variable</var>]]</code> or <code>BURIEDP [[] [] [<var>proplist</var>]]</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "trace",
            "description": "<pre class=\"example\">TRACE contentslist</pre><p>command.  Marks the named items for tracing.  A message is printed whenever a traced procedure is invoked, giving the actual input values, and whenever a traced procedure <code>STOP</code>s or <code>OUTPUT</code>s.  A message is printed whenever a new value is assigned to a traced variable using <code>MAKE</code>.  A message is printed whenever a new property is given to a traced property list using <code>PPROP</code>.</p>",
            "seeAlso": [
              "stop",
              "output",
              "make",
              "pprop"
            ]
          },
          {
            "command": "untrace",
            "description": "<pre class=\"example\">UNTRACE contentslist</pre><p>command.  Turns off tracing for the named items.</p>",
            "seeAlso": []
          },
          {
            "command": "tracedp",
            "description": "<pre class=\"example\">TRACEDP contentslist\nTRACED? contentslist</pre><p>outputs <code>TRUE</code> if the first procedure, variable, or property list named in the contents list is traced, <code>FALSE</code> if not.  Only the first thing in the list is tested; the most common use will be with a word as input, naming a procedure, but a contents list is allowed so that you can <code>TRACEDP [[] [<var>variable</var>]]</code> or <code>TRACEDP [[] [] [<var>proplist</var>]]</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "step",
            "description": "<pre class=\"example\">STEP contentslist</pre><p>command.  Marks the named items for stepping.  Whenever a stepped procedure is invoked, each instruction line in the procedure body is printed before being executed, and Logo waits for the user to type a newline at the terminal.  A message is printed whenever a stepped variable name is <em>shadowed</em> because a local variable of the same name is created either as a procedure input or by the <code>LOCAL</code> command.</p>",
            "seeAlso": [
              "local"
            ]
          },
          {
            "command": "unstep",
            "description": "<pre class=\"example\">UNSTEP contentslist</pre><p>command.  Turns off stepping for the named items.</p>",
            "seeAlso": []
          },
          {
            "command": "steppedp",
            "description": "<pre class=\"example\">STEPPEDP contentslist\nSTEPPED? contentslist</pre><p>outputs <code>TRUE</code> if the first procedure, variable, or property list named in the contents list is stepped, <code>FALSE</code> if not.  Only the first thing in the list is tested; the most common use will be with a word as input, naming a procedure, but a contents list is allowed so that you can <code>STEPPEDP [[] [<var>variable</var>]]</code> or <code>STEPPEDP [[] [] [<var>proplist</var>]]</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "edit",
            "description": "<pre class=\"example\">EDIT contentslist\nED contentslist\n(EDIT)\n(ED)</pre><p>command.  If invoked with an input, <code>EDIT</code> writes the definitions of the named items into a temporary file and edits that file, using an editor that depends on the platform you&apos;re using.  In wxWidgets, and in the MacOS Classic version, there is an editor built into Logo.  In the non-wxWidgets versions for Unix, MacOS X, Windows, and DOS, Logo uses your favorite editor as determined by the <code>EDITOR</code> environment variable.  If you don&apos;t have an <code>EDITOR</code> variable, edits the definitions using <code>jove</code>.  If invoked without an input, <code>EDIT</code> edits the same file left over from a previous <code>EDIT</code> or <code>EDITFILE</code> instruction.  When you leave the editor, Logo reads the revised definitions and modifies the workspace accordingly.  It is not an error if the input includes names for which there is no previous definition.</p><p>If there is a variable <code>LOADNOISILY</code> whose value is <code>TRUE</code>, then, after leaving the editor, <code>TO</code> commands in the temporary file print &#x2018;<samp><var>procname</var> defined</samp>&#x2019; (where <var>procname</var> is the name of the procedure being defined); if <code>LOADNOISILY</code> is <code>FALSE</code> or undefined, <code>TO</code> commands in the file are carried out silently.</p><p>If there is an environment variable called <code>TEMP</code>, then Logo uses its value as the directory in which to write the temporary file used for editing.</p><p>Exceptionally, the <code>EDIT</code> command can be used without its default input and without parentheses provided that nothing follows it on the instruction line.</p>",
            "seeAlso": [
              "loadnoisily",
              "editfile"
            ]
          },
          {
            "command": "editfile",
            "description": "<pre class=\"example\">EDITFILE filename</pre><p>command.  Starts the Logo editor, like <code>EDIT</code>, but instead of editing a temporary file it edits the file specified by the input.  When you leave the editor, Logo reads the revised file, as for <code>EDIT</code>.  <code>EDITFILE</code> also remembers the filename, so that a subsequent <code>EDIT</code> command with no input will re-edit the same file.</p><p><code>EDITFILE</code> is intended as an alternative to <code>LOAD</code> and <code>SAVE</code>. You can maintain a workspace file yourself, controlling the order in which definitions appear, maintaining comments in the file, and so on.</p><p>In the wxWidgets version, <code>EDITFILE</code> asks whether or not you want to load the file into Logo when you finish editing.  This allows you to use <code>EDITFILE</code> to edit data files without leaving Logo.</p>",
            "seeAlso": []
          },
          {
            "command": "edall",
            "description": "<pre class=\"example\">EDALL</pre><p>command.  Abbreviates <tt>EDIT CONTENTS</tt>.</p>",
            "seeAlso": [
              "contents"
            ]
          },
          {
            "command": "edps",
            "description": "<pre class=\"example\">EDPS</pre><p>command.  Abbreviates <tt>EDIT PROCEDURES</tt>.</p>",
            "seeAlso": [
              "edit",
              "procedures"
            ]
          },
          {
            "command": "edns",
            "description": "<pre class=\"example\">EDNS</pre><p>command.  Abbreviates <tt>EDIT NAMES</tt>.</p>",
            "seeAlso": [
              "edit",
              "names"
            ]
          },
          {
            "command": "edpls",
            "description": "<pre class=\"example\">EDPLS</pre><p>command.  Abbreviates <tt>EDIT PLISTS</tt>.</p>",
            "seeAlso": [
              "edit",
              "plists"
            ]
          },
          {
            "command": "edn",
            "description": "<pre class=\"example\">EDN varname\nEDN varnamelist</pre><p>command.  Abbreviates <tt>EDIT NAMELIST <var>varname(list)</var></tt>.</p>",
            "seeAlso": [
              "edit",
              "namelist"
            ]
          },
          {
            "command": "edpl",
            "description": "<pre class=\"example\">EDPL plname\nEDPL plnamelist</pre><p>command.  Abbreviates <tt>EDIT PLLIST <var>plname(list)</var></tt>.</p>",
            "seeAlso": [
              "edit",
              "pllist"
            ]
          },
          {
            "command": "save",
            "description": "<pre class=\"example\">SAVE filename</pre><p>command.  Saves the definitions of all unburied procedures, variables, and nonempty property lists in the named file.  Equivalent to</p><pre class=\"example\">to save :filename\nlocal &quot;oldwriter\nmake &quot;oldwriter writer\nopenwrite :filename\nsetwrite :filename\npoall\nsetwrite :oldwriter\nclose :filename\nend</pre><p>Exceptionally, <code>SAVE</code> can be used with no input and without parentheses if it is the last thing on the command line.  In this case, the filename from the most recent <code>LOAD</code> or <code>SAVE</code> command will be used.  (It is an error if there has been no previous <code>LOAD</code> or <code>SAVE</code>.)</p>",
            "seeAlso": []
          },
          {
            "command": "savel",
            "description": "<pre class=\"example\">SAVEL contentslist filename</pre><p>command.  Saves the definitions of the procedures, variables, and property lists specified by <var>contentslist</var> to the file named <var>filename</var>.</p>",
            "seeAlso": []
          },
          {
            "command": "load",
            "description": "<pre class=\"example\">LOAD filename</pre><p>command.  Reads instructions from the named file and executes them.  The file can include procedure definitions with <code>TO</code>, and these are accepted even if a procedure by the same name already exists.  If the file assigns a list value to a variable named <code>STARTUP</code>, then that list is run as an instructionlist after the file is loaded. If there is a variable <code>LOADNOISILY</code> whose value is <code>TRUE</code>, then <code>TO</code> commands in the file print &#x2018;<samp><var>procname</var> defined</samp>&#x2019; (where <var>procname</var> is the name of the procedure being defined); if <code>LOADNOISILY</code> is <code>FALSE</code> or undefined, <code>TO</code> commands in the file are carried out silently.</p>",
            "seeAlso": [
              "startup",
              "loadnoisily"
            ]
          },
          {
            "command": "cslsload",
            "description": "<pre class=\"example\">CSLSLOAD name</pre><p>command.  Loads the named file, like <code>LOAD</code>, but from the directory containing the Computer Science Logo Style programs instead of the current user&apos;s directory.</p>",
            "seeAlso": [
              "load"
            ]
          },
          {
            "command": "help",
            "description": "<pre class=\"example\">HELP name\n(HELP)</pre><p>command.  Prints information from the reference manual about the primitive procedure named by the input.  With no input, lists all the primitives about which help is available.  If there is an environment variable <code>LOGOHELP</code>, then its value is taken as the directory in which to look for help files, instead of the default help directory.</p><p>If <code>HELP</code> is called with the name of a defined procedure for which there is no help file, it will print the title line of the procedure followed by lines from the procedure body that start with semicolon, stopping when a non-semicolon line is seen.</p><p>Exceptionally, the <code>HELP</code> command can be used without its default input and without parentheses provided that nothing follows it on the instruction line.</p>",
            "seeAlso": []
          },
          {
            "command": "seteditor",
            "description": "<pre class=\"example\">SETEDITOR path</pre><p>command.  Tells Logo to use the specified program as its editor instead of the default editor.  The format of a path depends on your operating system.</p>",
            "seeAlso": []
          },
          {
            "command": "setlibloc",
            "description": "<pre class=\"example\">SETLIBLOC path</pre><p>command.  Tells Logo to use the specified directory as its library instead of the default.  (Note that many Logo &quot;primitive&quot; procedures are actually found in the library, so they may become unavailable if your new library does not include them!)  The format of a path depends on your operating system.</p>",
            "seeAlso": []
          },
          {
            "command": "setcslsloc",
            "description": "<pre class=\"example\">SETCSLSLOC path</pre><p>command.  Tells Logo to use the specified directory for the <code>CSLSLOAD</code> command, instead of the default directory.  The format of a path depends on your operating system.</p>",
            "seeAlso": [
              "cslsload"
            ]
          },
          {
            "command": "sethelploc",
            "description": "<pre class=\"example\">SETHELPLOC path</pre><p>command.  Tells Logo to look in the specified directory for the information provided by the HELP command, instead of the default directory. The format of a path depends on your operating system.</p>",
            "seeAlso": []
          },
          {
            "command": "settemploc",
            "description": "<pre class=\"example\">SETTEMPLOC path</pre><p>command.  Tells Logo to write editor temporary files in the specified directory rather than in the default directory.  You must have write permission for this directory.  The format of a path depends on your operating system.</p>",
            "seeAlso": []
          },
          {
            "command": "gc",
            "description": "<pre class=\"example\">GC\n(GC anything)</pre><p>command.  Runs the garbage collector, reclaiming unused nodes.  Logo does this when necessary anyway, but you may want to use this command to control exactly when Logo does it.  In particular, the numbers output by the <code>NODES</code> operation will not be very meaningful unless garbage has been collected.  Another reason to use <code>GC</code> is that a garbage collection takes a noticeable fraction of a second, and you may want to schedule collections for times before or after some time-critical animation.  If invoked with an argument (of any value), <code>GC</code> runs a full garbage collection, including <acronym>GCTWA</acronym> (Garbage Collect Truly Worthless Atoms, which means that it removes from Logo&apos;s memory words that used to be procedure or variable names but aren&apos;t any more); without an argument, <code>GC</code> does a generational garbage collection, which means that only recently created nodes are examined.  (The latter is usually good enough.)</p>",
            "seeAlso": []
          },
          {
            "command": ".setsegmentsize",
            "description": "<pre class=\"example\">.SETSEGMENTSIZE num</pre><p>command.  Sets the number of nodes that Logo allocates from the operating system at once to <var>num</var>, which must be a positive integer. The name is dotted because bad things will happen if you use a number that&apos;s too small or too large for your computer.  The initial value is 16,000 for most systems, but is smaller for 68000-based Macs.  Making it larger will speed up computations (by reducing the number of garbage collections) at the cost of allocating more memory than necessary.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  },
  {
    "number": 8,
    "title": "Control Structures",
    "sections": [
      {
        "number": 8.1,
        "title": "Control",
        "commands": [
          {
            "command": "run",
            "description": "<pre class=\"example\">RUN instructionlist</pre><p>command or operation.  Runs the Logo instructions in the input list; outputs if the list contains an expression that outputs.</p>",
            "seeAlso": [
              "readword",
              "readlist"
            ]
          },
          {
            "command": "runresult",
            "description": "<pre class=\"example\">RUNRESULT instructionlist</pre><p>runs the instructions in the input; outputs an empty list if those instructions produce no output, or a list whose only member is the output from running the input instructionlist.  Useful for inventing command-or-operation control structures:</p><pre class=\"example\">local &quot;result\nmake &quot;result runresult [something]\nif emptyp :result [stop]\noutput first :result</pre>",
            "seeAlso": []
          },
          {
            "command": "repeat",
            "description": "<pre class=\"example\">REPEAT num instructionlist</pre><p>command.  Runs the <var>instructionlist</var> repeatedly, <var>num</var> times.</p>",
            "seeAlso": []
          },
          {
            "command": "forever",
            "description": "<pre class=\"example\">FOREVER instructionlist</pre><p>command.  Runs the &quot;instructionlist&quot; repeatedly, until something inside the instructionlist (such as <code>STOP</code> or <code>THROW</code>) makes it stop.</p>",
            "seeAlso": [
              "stop",
              "throw"
            ]
          },
          {
            "command": "repcount",
            "description": "<pre class=\"example\">REPCOUNT</pre><p>outputs the repetition count of the innermost current <code>REPEAT</code> or <code>FOREVER</code>, starting from 1.  If no <code>REPEAT</code> or <code>FOREVER</code> is active, outputs &#x2013;1.</p><p>The abbreviation <code>#</code> can be used for <code>REPCOUNT</code> unless the <code>REPEAT</code> is inside the template input to a higher order procedure such as <code>FOREACH</code>, in which case <code>#</code> has a different meaning.</p>",
            "seeAlso": []
          },
          {
            "command": "if",
            "description": "<pre class=\"example\">IF tf instructionlist\n(IF tf instructionlist1 instructionlist2)</pre><p>command.  If the first input has the value <code>TRUE</code>, then <code>IF</code> runs the second input.  If the first input has the value <code>FALSE</code>, then <code>IF</code> does nothing. (If given a third input, IF acts like <code>IFELSE</code>, as described below.)  It is an error if the first input is not either <code>TRUE</code> or <code>FALSE</code>.</p><p>For compatibility with earlier versions of Logo, if an <code>IF</code> instruction is not enclosed in parentheses, but the first thing on the instruction line after the second input expression is a literal list (i.e., a list in square brackets), the <code>IF</code> is treated as if it were <code>IFELSE</code>, but a warning message is given.  If this aberrant <code>IF</code> appears in a procedure body, the warning is given only the first time the procedure is invoked in each Logo session.</p>",
            "seeAlso": []
          },
          {
            "command": "ifelse",
            "description": "<pre class=\"example\">IFELSE tf instructionlist1 instructionlist2</pre><p>command or operation.  If the first input has the value <code>TRUE</code>, then <code>IFELSE</code> runs the second input.  If the first input has the value <code>FALSE</code>, then <code>IFELSE</code> runs the third input.  <code>IFELSE</code> outputs a value if the <var>instructionlist</var> contains an expression that outputs a value.</p>",
            "seeAlso": []
          },
          {
            "command": "test",
            "description": "<pre class=\"example\">TEST tf</pre><p>command.  Remembers its input, which must be <code>TRUE</code> or <code>FALSE</code>, for use by later <code>IFTRUE</code> or <code>IFFALSE</code> instructions.  The effect of <code>TEST</code> is local to the procedure in which it is used; any corresponding <code>IFTRUE</code> or <code>IFFALSE</code> must be in the same procedure or a subprocedure.</p>",
            "seeAlso": [
              "iffalse"
            ]
          },
          {
            "command": "iftrue",
            "description": "<pre class=\"example\">IFTRUE instructionlist\nIFT instructionlist</pre><p>command.  Runs its input if the most recent <code>TEST</code> instruction had a <code>TRUE</code> input.  The <code>TEST</code> must have been in the same procedure or a superprocedure.</p>",
            "seeAlso": []
          },
          {
            "command": "iffalse",
            "description": "<pre class=\"example\">IFFALSE instructionlist\nIFF instructionlist</pre><p>command.  Runs its input if the most recent <code>TEST</code> instruction had a <code>FALSE</code> input.  The <code>TEST</code> must have been in the same procedure or a superprocedure.</p>",
            "seeAlso": [
              "test"
            ]
          },
          {
            "command": "stop",
            "description": "<pre class=\"example\">STOP</pre><p>command.  Ends the running of the procedure in which it appears. Control is returned to the context in which that procedure was invoked. The stopped procedure does not output a value.</p>",
            "seeAlso": []
          },
          {
            "command": "output",
            "description": "<pre class=\"example\">OUTPUT value\nOP value</pre><p>command.  Ends the running of the procedure in which it appears.  That procedure outputs the value <var>value</var> to the context in which it was invoked.  Don&apos;t be confused: <code>OUTPUT</code> itself is a command, but the procedure that invokes <code>OUTPUT</code> is an operation.</p>",
            "seeAlso": []
          },
          {
            "command": "catch",
            "description": "<pre class=\"example\">CATCH tag instructionlist</pre><p>command or operation.  Runs its second input.  Outputs if that <var>instructionlist</var> outputs.  If, while running the instructionlist, a <code>THROW</code> instruction is executed with a tag equal to the first input (case-insensitive comparison), then the running of the <var>instructionlist</var> is terminated immediately.  In this case the <code>CATCH</code> outputs if a value input is given to <code>THROW</code>.  The <var>tag</var> must be a word.</p><p>If the tag is the word <code>ERROR</code>, then any error condition that arises during the running of the instructionlist has the effect of <tt>THROW &quot;ERROR</tt> instead of printing an error message and returning to toplevel.  The <code>CATCH</code> does not output if an error is caught.  Also, during the running of the instructionlist, the variable <code>ERRACT</code> is temporarily unbound.  (If there is an error while <code>ERRACT</code> has a value, that value is taken as an instructionlist to be run after printing the error message.  Typically the value of <code>ERRACT</code>, if any, is the list <code>[PAUSE]</code>.)</p>",
            "seeAlso": [
              "error",
              "erract",
              "pause"
            ]
          },
          {
            "command": "throw",
            "description": "<pre class=\"example\">THROW tag\n(THROW tag value)</pre><p>command.  Must be used within the scope of a <code>CATCH</code> with an equal tag. Ends the running of the instructionlist of the <code>CATCH</code>.  If <code>THROW</code> is used with only one input, the corresponding <code>CATCH</code> does not output a value. If <code>THROW</code> is used with two inputs, the second provides an output for the <code>CATCH</code>.</p><p><tt>THROW &quot;TOPLEVEL</tt> can be used to terminate all running procedures and interactive pauses, and return to the toplevel instruction prompt.  Typing the system interrupt character (&lt;alt-S&gt; for wxWidgets; otherwise normally &lt;control-C&gt; for Unix, &lt;control-Q&gt; for DOS, or &lt;command-period&gt; for Mac) has the same effect.</p><p><tt>THROW &quot;ERROR</tt> can be used to generate an error condition.  If the error is not caught, it prints a message (<code>THROW &quot;ERROR</code>) with the usual indication of where the error (in this case the <code>THROW</code>) occurred.  If a second input is used along with a tag of <code>ERROR</code>, that second input is used as the text of the error message instead of the standard message. Also, in this case, the location indicated for the error will be, not the location of the <code>THROW</code>, but the location where the procedure containing the <code>THROW</code> was invoked.  This allows user-defined procedures to generate error messages as if they were primitives.  Note: in this case the corresponding <tt>CATCH &quot;ERROR</tt>, if any, does not output, since the second input to <code>THROW</code> is not considered a return value.</p><p><tt>THROW &quot;SYSTEM</tt> immediately leaves Logo, returning to the operating system, without printing the usual parting message and without deleting any editor temporary file written by EDIT.</p>",
            "seeAlso": [
              "edit"
            ]
          },
          {
            "command": "error",
            "description": "<pre class=\"example\">ERROR</pre><p>outputs a list describing the error just caught, if any.  If there was not an error caught since the last use of <code>ERROR</code>, the empty list will be output.  The error list contains four members: an integer code corresponding to the type of error, the text of the error message (as a single word including spaces), the name of the procedure in which the error occurred, and the instruction line on which the error occurred.</p>",
            "seeAlso": []
          },
          {
            "command": "pause",
            "description": "<pre class=\"example\">PAUSE</pre><p>command or operation.  Enters an interactive pause.  The user is prompted for instructions, as at toplevel, but with a prompt that includes the name of the procedure in which <code>PAUSE</code> was invoked.  Local variables of that procedure are available during the pause.  <code>PAUSE</code> outputs if the pause is ended by a <code>CONTINUE</code> with an input.</p><p>If the variable <code>ERRACT</code> exists, and an error condition occurs, the contents of that variable are run as an instructionlist.  Typically <code>ERRACT</code> is given the value <code>[PAUSE]</code> so that an interactive pause will be entered in the event of an error.  This allows the user to check values of local variables at the time of the error.</p><p>Typing the system quit character (&lt;alt-S&gt; for wxWidgets; otherwise normally &lt;control-\\&gt; for Unix, &lt;control-W&gt; for DOS, or &lt;command-comma&gt; for Mac) will also enter a pause.</p>",
            "seeAlso": [
              "erract"
            ]
          },
          {
            "command": "continue",
            "description": "<pre class=\"example\">CONTINUE value\nCO value\n(CONTINUE)\n(CO)</pre><p>command.  Ends the current interactive pause, returning to the context of the <code>PAUSE</code> invocation that began it.  If <code>CONTINUE</code> is given an input, that value is used as the output from the <code>PAUSE</code>.  If not, the <code>PAUSE</code> does not output.</p><p>Exceptionally, the <code>CONTINUE</code> command can be used without its default input and without parentheses provided that nothing follows it on the instruction line.</p>",
            "seeAlso": []
          },
          {
            "command": "wait",
            "description": "<pre class=\"example\">WAIT time</pre><p>command.  Delays further execution for <var>time</var> 60ths of a second.  Also causes any buffered characters destined for the terminal to be printed immediately.  <tt>WAIT 0</tt> can be used to achieve this buffer flushing without actually waiting.</p>",
            "seeAlso": []
          },
          {
            "command": "bye",
            "description": "<pre class=\"example\">BYE</pre><p>command.  Exits from Logo; returns to the operating system.</p>",
            "seeAlso": []
          },
          {
            "command": ".maybeoutput",
            "description": "<pre class=\"example\">.MAYBEOUTPUT value\t\t\t\t(special form)</pre><p>works like <code>OUTPUT</code> except that the expression that provides the input value might not, in fact, output a value, in which case the effect is like <code>STOP</code>.  This is intended for use in control structure definitions, for cases in which you don&apos;t know whether or not some expression produces a value.  Example:</p><pre class=\"example\">to invoke :function [:inputs] 2\n.maybeoutput apply :function :inputs\nend\n\n? (invoke &quot;print &quot;a &quot;b &quot;c)\na b c\n? print (invoke &quot;word &quot;a &quot;b &quot;c)\nabc</pre><p>This is an alternative to <code>RUNRESULT</code>.  It&apos;s fast and easy to use, at the cost of being an exception to Logo&apos;s evaluation rules.  (Ordinarily, it should be an error if the expression that&apos;s supposed to provide an input to something doesn&apos;t have a value.)</p>",
            "seeAlso": [
              "output",
              "stop",
              "runresult"
            ]
          },
          {
            "command": "goto",
            "description": "<pre class=\"example\">GOTO word</pre><p>command.  Looks for a <code>TAG</code> command with the same input in the same procedure, and continues running the procedure from the location of that <code>TAG</code>.  It is meaningless to use <code>GOTO</code> outside of a procedure.</p>",
            "seeAlso": []
          },
          {
            "command": "tag",
            "description": "<pre class=\"example\">TAG quoted.word</pre><p>command.  Does nothing.  The input must be a literal word following a quotation mark (<code>&quot;</code>), not the result of a computation.  Tags are used by the <code>GOTO</code> command.</p>",
            "seeAlso": []
          },
          {
            "command": "ignore",
            "description": "<pre class=\"example\">IGNORE value</pre><p>command.  Does nothing.  Used when an expression is evaluated for a side effect and its actual value is unimportant.</p>",
            "seeAlso": []
          },
          {
            "command": "`",
            "description": "<pre class=\"example\">` list</pre><p>outputs a list equal to its input but with certain substitutions.  If a member of the input list is the word &#x2018;<samp>,</samp>&#x2019; (comma) then the following member should be an instructionlist that produces an output when run. That output value replaces the comma and the instructionlist.  If a member of the input list is the word &#x2018;<samp>,@</samp>&#x2019; (comma atsign) then the following member should be an instructionlist that outputs a list when run.  The members of that list replace the &#x2018;<samp>,@</samp>&#x2019; and the instructionlist. Example:</p><pre class=\"example\">show `[foo baz ,[bf [a b c]] garply ,@[bf [a b c]]]</pre><p>will print</p><pre class=\"example\">[foo baz [b c] garply b c]</pre><p>A word starting with &#x2018;<samp>,</samp>&#x2019; or &#x2018;<samp>,@</samp>&#x2019; is treated as if the rest of the word were a one-word list, e.g., &#x2018;<samp>,:foo</samp>&#x2019; is equivalent to &#x2018;<samp>,[:Foo]</samp>&#x2019;.</p><p>A word starting with &#x2018;<samp>&quot;,</samp>&#x2019; (quote comma) or &#x2018;<samp>:,</samp>&#x2019; (colon comma) becomes a word starting with &#x2018;<samp>&quot;</samp>&#x2019; or &#x2018;<samp>:</samp>&#x2019; but with the result of running the substitution (or its first word, if the result is a list) replacing what comes after the comma.</p><p>Backquotes can be nested.  Substitution is done only for commas at the same depth as the backquote in which they are found:</p><pre class=\"example\">? show `[a `[b ,[1+2] ,[foo ,[1+3] d] e] f]\n[a ` [b , [1+2] , [foo 4 d] e] f]\n\n?make &quot;name1 &quot;x\n?make &quot;name2 &quot;y\n? show `[a `[b ,:,:name1 ,&quot;,:name2 d] e]\n[a ` [b , [:x] , [&quot;y] d] e]</pre>",
            "seeAlso": []
          },
          {
            "command": "for",
            "description": "<pre class=\"example\">FOR forcontrol instructionlist</pre><p>command.  The first input must be a list containing three or four members: (1) a word, which will be used as the name of a local variable; (2) a word or list that will be evaluated as by <code>RUN</code> to determine a number, the starting value of the variable; (3) a word or list that will be evaluated to determine a number, the limit value of the variable; (4) an optional word or list that will be evaluated to determine the step size.  If the fourth member is missing, the step size will be 1 or &#x2013;1 depending on whether the limit value is greater than or less than the starting value, respectively.</p><p>The second input is an instructionlist.  The effect of <code>FOR</code> is to run that instructionlist repeatedly, assigning a new value to the control variable (the one named by the first member of the <var>forcontrol</var> list) each time.  First the starting value is assigned to the control variable. Then the value is compared to the limit value.  <code>FOR</code> is complete when the sign of <code>(current - limit)</code> is the same as the sign of the step size.  (If no explicit step size is provided, the instructionlist is always run at least once.  An explicit step size can lead to a zero-trip <code>FOR</code>, e.g., <tt>FOR [I 1 0 1] ...</tt>). Otherwise, the instructionlist is run, then the step is added to the current value of the control variable and FOR returns to the comparison step.</p><pre class=\"example\">? for [i 2 7 1.5] [print :i]\n2\n3.5\n5\n6.5\n?</pre>",
            "seeAlso": [
              "run"
            ]
          },
          {
            "command": "do.while",
            "description": "<pre class=\"example\">DO.WHILE instructionlist tfexpression</pre><p>command.  Repeatedly evaluates the <var>instructionlist</var> as long as the evaluated  remains <code>TRUE</code>.  Evaluates the first input first, so the <var>instructionlist</var> is always run at least once.  The <var>tfexpression</var> must be an expressionlist whose value when evaluated is <code>TRUE</code> or <code>FALSE</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "while",
            "description": "<pre class=\"example\">WHILE tfexpression instructionlist</pre><p>command.  Repeatedly evaluates the <var>instructionlist</var> as long as the evaluated remains <code>TRUE</code>.  Evaluates the first input first, so the <var>instructionlist</var> may never be run at all.  The <var>tfexpression</var> must be an expressionlist whose value when evaluated is <code>TRUE</code> or <code>FALSE</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "do.until",
            "description": "<pre class=\"example\">DO.UNTIL instructionlist tfexpression</pre><p>command.  Repeatedly evaluates the <var>instructionlist</var> as long as the evaluated remains <code>FALSE</code>.  Evaluates the first input first, so the <var>instructionlist</var> is always run at least once.  The <var>tfexpression</var> must be an expressionlist whose value when evaluated is <code>TRUE</code> or <code>FALSE</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "until",
            "description": "<pre class=\"example\">UNTIL tfexpression instructionlist</pre><p>command.  Repeatedly evaluates the <var>instructionlist</var> as long as the evaluated remains <code>FALSE</code>.  Evaluates the first input first, so the <var>instructionlist</var> may never be run at all.  The <var>tfexpression</var> must be an expressionlist whose value when evaluated is <code>TRUE</code> or <code>FALSE</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "case",
            "description": "<pre class=\"example\">CASE value clauses</pre><p>command or operation.  The second input is a list of lists (clauses); each clause is a list whose first element is either a list of values or the word <code>ELSE</code> and whose butfirst is a Logo expression or instruction.  <code>CASE</code> examines the clauses in order.  If a clause begins with the word <code>ELSE</code> (upper or lower case), then the butfirst of that clause is evaluated and <code>CASE</code> outputs its value, if any.  If the first input to CASE is a member of the first element of a clause, then the butfirst of that clause is evaluated and <code>CASE</code> outputs its value, if any.  If neither of these conditions is met, then <code>CASE</code> goes on to the next clause.  If no clause is satisfied, <code>CASE</code> does nothing.   Example:</p><pre class=\"example\">to vowelp :letter\noutput case :letter [ [[a e i o u] &quot;true] [else &quot;false] ]\nend</pre>",
            "seeAlso": []
          },
          {
            "command": "cond",
            "description": "<pre class=\"example\">COND clauses</pre><p>command or operation.  The input is a list of lists (clauses); each clause is a list whose first element is either an expression whose value is <code>TRUE</code> or <code>FALSE</code>, or the word <code>ELSE</code>, and whose butfirst is a Logo expression or instruction.  <code>COND</code> examines the clauses in order.  If a clause begins with the word <code>ELSE</code> (upper or lower case), then the butfirst of that clause is evaluated and <code>CASE</code> outputs its value, if any.  Otherwise, the first element of the clause is evaluated; the resulting value must be <code>TRUE</code> or <code>FALSE</code>.  If it&apos;s <code>TRUE</code>, then the butfirst of that clause is evaluated and <code>COND</code> outputs its value, if any.  If the value is <code>FALSE</code>, then <code>COND</code> goes on to the next clause.  If no clause is satisfied, <code>COND</code> does nothing.  Example:</p><pre class=\"example\">to evens :numbers\t; select even numbers from a list\nop cond [ [[emptyp :numbers] []]\n          [[evenp first :numbers]\t; assuming EVENP is defined\n           fput first :numbers evens butfirst :numbers]\n          [else evens butfirst :numbers] ]\nend</pre>",
            "seeAlso": []
          }
        ]
      },
      {
        "number": 8.2,
        "title": "Template-based Iteration",
        "commands": [
          {
            "command": "apply",
            "description": "<pre class=\"example\">APPLY template inputlist</pre><p>command or operation.  Runs the <var>template</var>, filling its slots with the members of <var>inputlist.</var>  The number of members in <var>inputlist</var> must be an acceptable number of slots for <var>template</var>.  It is illegal to apply the primitive <code>TO</code> as a template, but anything else is okay.  <code>APPLY</code> outputs what <var>template</var> outputs, if anything.</p>",
            "seeAlso": [
              "to"
            ]
          },
          {
            "command": "invoke",
            "description": "<pre class=\"example\">INVOKE template input\n(INVOKE template input1 input2 ...)</pre><p>command or operation.  Exactly like <code>APPLY</code> except that the inputs are provided as separate expressions rather than in a list.</p>",
            "seeAlso": []
          },
          {
            "command": "foreach",
            "description": "<pre class=\"example\">FOREACH data template\n(FOREACH data1 data2 ... template)</pre><p>command.  Evaluates the <var>template</var> list repeatedly, once for each member of the <var>data</var> list.  If more than one <var>data</var> list are given, each of them must be the same length.  (The <var>data</var> inputs can be words, in which case the template is evaluated once for each character.)</p><p>In a template, the symbol <code>?REST</code> represents the portion of the <var>data</var> input to the right of the member currently being used as the <code>?</code> slot-filler.  That is, if the <var>data</var> input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>?REST</code> would be replaced by <code>[C D E]</code>.  If multiple parallel slots are used, then <tt>(?REST 1)</tt> goes with ?1, etc.</p><p>In a template, the symbol <code>#</code> represents the position in the <var>data</var> input of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>#</code> would be replaced by <code>2</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "map",
            "description": "<pre class=\"example\">MAP template data\n(MAP template data1 data2 ...)</pre><p>outputs a word or list, depending on the type of the <var>data</var> input, of the same length as that <var>data</var> input.  (If more than one <var>data</var> input are given, the output is of the same type as <var>data1</var>.)  Each member of the output is the result of evaluating the <var>template</var> list, filling the slots with the corresponding member(s) of the <var>data</var> input(s).  (All <var>data</var> inputs must be the same length.)  In the case of a word output, the results of the template evaluation must be words, and they are concatenated with <code>WORD</code>.</p><p>In a template, the symbol <code>?REST</code> represents the portion of the data input to the right of the member currently being used as the <code>?</code> slot-filler.  That is, if the <var>data</var> input is <code>[A B C D E]</code> and the <var>template</var> is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>?REST</code> would be replaced by <code>[C D E]</code>. If multiple parallel slots are used, then <tt>(?REST 1)</tt> goes with <code>?1</code>, etc.</p><p>In a template, the symbol <code>#</code> represents the position in the <var>data</var> input of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>#</code> would be replaced by <code>2</code>.</p>",
            "seeAlso": [
              "word"
            ]
          },
          {
            "command": "map.se",
            "description": "<pre class=\"example\">MAP.SE template data\n(MAP.SE template data1 data2 ...)</pre><p>outputs a list formed by evaluating the <var>template</var> list repeatedly and concatenating the results using <code>SENTENCE</code>.  That is, the members of the output are the members of the results of the evaluations.  The output list might, therefore, be of a different length from that of the <var>data</var> input(s).  (If the result of an evaluation is the empty list, it contributes nothing to the final output.)  The <var>data</var> inputs may be words or lists.</p><p>In a template, the symbol <code>?REST</code> represents the portion of the data input to the right of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>?REST</code> would be replaced by <code>[C D E]</code>. If multiple parallel slots are used, then <tt>(?REST 1)</tt> goes with <code>?1</code>, etc.</p><p>In a template, the symbol <code>#</code> represents the position in the <var>data</var> input of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>#</code> would be replaced by <code>2</code>.</p>",
            "seeAlso": [
              "sentence"
            ]
          },
          {
            "command": "filter",
            "description": "<pre class=\"example\">FILTER tftemplate data</pre><p>outputs a word or list, depending on the type of the <var>data</var> input, containing a subset of the members (for a list) or characters (for a word) of the input.  The template is evaluated once for each member or character of the data, and it must produce a <code>TRUE</code> or <code>FALSE</code> value.  If the value is <code>TRUE</code>, then the corresponding input constituent is included in the output.</p><pre class=\"example\">? print filter &quot;vowelp &quot;elephant \neea \n?</pre><p>In a template, the symbol <code>?REST</code> represents the portion of the <var>data</var> input to the right of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>?REST</code> would be replaced by <code>[C D E]</code>.</p><p>In a template, the symbol <code>#</code> represents the position in the <var>data</var> input of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>#</code> would be replaced by <code>2</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "find",
            "description": "<pre class=\"example\">FIND tftemplate data</pre><p>outputs the first constituent of the <var>data</var> input (the first member of a list, or the first character of a word) for which the value produced by evaluating the <var>template</var> with that consituent in its slot is <code>TRUE</code>. If there is no such constituent, the empty list is output.</p><p>In a template, the symbol <code>?REST</code> represents the portion of the <var>data</var> input to the right of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>?REST</code> would be replaced by <code>[C D E]</code>.</p><p>In a template, the symbol <code>#</code> represents the position in the <var>data</var> input of the member currently being used as the <code>?</code> slot-filler.  That is, if the data input is <code>[A B C D E]</code> and the template is being evaluated with <code>?</code> replaced by <code>B</code>, then <code>#</code> would be replaced by <code>2</code>.</p>",
            "seeAlso": []
          },
          {
            "command": "reduce",
            "description": "<pre class=\"example\">REDUCE template data</pre><p>outputs the result of applying the <var>template</var> to accumulate the members of the <var>data</var> input.  The template must be a two-slot function.  Typically it is an associative function name like <code>SUM</code>.  If the <var>data</var> input has only one constituent (member in a list or character in a word), the output is that consituent.  Otherwise, the template is first applied with <code>?1</code> filled with the next-to-last consitient and <code>?2</code> with the last constituent.  Then, if there are more constituents, the template is applied with <code>?1</code> filled with the next constituent to the left and <code>?2</code> with the result from the previous evaluation.  This process continues until all constituents have been used.  The data input may not be empty.</p><p>Note: If the template is, like <code>SUM</code>, the name of a procedure that is capable of accepting arbitrarily many inputs, it is more efficient to use <code>APPLY</code> instead of <code>REDUCE</code>.  The latter is good for associative procedures that have been written to accept exactly two inputs:</p><pre class=\"example\">to max :a :b\noutput ifelse :a &gt; :b [:a] [:b]\nend\n\nprint reduce &quot;max [...]</pre><p>Alternatively, <code>REDUCE</code> can be used to write <code>MAX</code> as a procedure that accepts any number of inputs, as <code>SUM</code> does:</p><pre class=\"example\">to max [:inputs] 2\nif emptyp :inputs ~\n   [(throw &quot;error [not enough inputs to max])]\noutput reduce [ifelse ?1 &gt; ?2 [?1] [?2]] :inputs\nend</pre>",
            "seeAlso": [
              "sum",
              "apply"
            ]
          },
          {
            "command": "crossmap",
            "description": "<pre class=\"example\">CROSSMAP template listlist\n(CROSSMAP template data1 data2 ...)</pre><p>outputs a list containing the results of template evaluations.  Each <var>data</var> list contributes to a slot in the template; the number of slots is equal to the number of <var>data</var> list inputs.  As a special case, if only one <var>data</var> list input is given, that list is taken as a list of data lists, and each of its members contributes values to a slot.  <code>CROSSMAP</code> differs from <code>MAP</code> in that instead of taking members from the data inputs in parallel, it takes all possible combinations of members of data inputs, which need not be the same length.</p><pre class=\"example\">? show (crossmap [word ?1 ?2] [a b c] [1 2 3 4])\n[a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4]\n?</pre><p>For compatibility with the version in the first edition of CSLS <a name=\"DOCF1\" href=\"usermanual_fot.html#FOOT1\">(1)</a>, <code>CROSSMAP</code> templates may use the notation <code>:1</code> instead of <code>?1</code> to indicate slots.</p>",
            "seeAlso": [
              "map"
            ]
          },
          {
            "command": "cascade",
            "description": "<pre class=\"example\">CASCADE endtest template startvalue\n(CASCADE endtest tmp1 sv1 tmp2 sv2 ...)\n(CASCADE endtest tmp1 sv1 tmp2 sv2 ... finaltemplate)</pre><p>outputs the result of applying a template (or several templates, as explained below) repeatedly, with a given value filling the slot the first time, and the result of each application filling the slot for the following application.</p><p>In the simplest case, <code>CASCADE</code> has three inputs.  The second input is a one-slot expression template.  That template is evaluated some number of times (perhaps zero).  On the first evaluation, the slot is filled with the third input; on subsequent evaluations, the slot is filled with the result of the previous evaluation.  The number of evaluations is determined by the first input.  This can be either a nonnegative integer, in which case the template is evaluated that many times, or a predicate expression template, in which case it is evaluated (with the same slot filler that will be used for the evaluation of the second input) repeatedly, and the <code>CASCADE</code> evaluation continues as long as the predicate value is <code>FALSE</code>.  (In other words, the predicate template indicates the condition for stopping.)</p><p>If the template is evaluated zero times, the output from <code>CASCADE</code> is the third (<var>startvalue</var>) input.  Otherwise, the output is the value produced by the last template evaluation.</p><p><code>CASCADE</code> templates may include the symbol <code>#</code> to represent the number of times the template has been evaluated.  This slot is filled with 1 for the first evaluation, 2 for the second, and so on.</p><pre class=\"example\">? show cascade 5 [lput # ?] []\n[1 2 3 4 5]\n? show cascade [vowelp first ?] [bf ?] &quot;spring\ning\n? show cascade 5 [# * ?] 1\n120\n?</pre><p>Several cascaded results can be computed in parallel by providing additional template-startvalue pairs as inputs to <code>CASCADE</code>.  In this case, all templates (including the endtest template, if used) are multi-slot, with the number of slots equal to the number of pairs of inputs.  In each round of evaluations, <code>?2</code>, for example, represents the result of evaluating the second template in the previous round.  If the total number of inputs (including the first endtest input) is odd, then the output from CASCADE is the final value of the first template.  If the total number of inputs is even, then the last input is a template that is evaluated once, after the end test is satisfied, to determine the output from <code>CASCADE</code>.</p><pre class=\"example\">to fibonacci :n\noutput (cascade :n [?1 + ?2] 1 [?1] 0)\nend\n\nto piglatin :word\noutput (cascade [vowelp first ?] ~\n                [word bf ? first ?] ~\n                :word ~\n                [word ? &quot;ay])\nend</pre>",
            "seeAlso": []
          },
          {
            "command": "cascade.2",
            "description": "<pre class=\"example\">CASCADE.2 endtest temp1 startval1 temp2 startval2</pre><p>outputs the result of invoking <code>CASCADE</code> with the same inputs.  The only difference is that the default number of inputs is five instead of three.</p>",
            "seeAlso": []
          },
          {
            "command": "transfer",
            "description": "<pre class=\"example\">TRANSFER endtest template inbasket</pre><p>outputs the result of repeated evaluation of the <var>template</var>.  The template is evaluated once for each member of the list <var>inbasket</var>.  <code>TRANSFER</code> maintains an <em>outbasket</em> that is initially the empty list.  After each evaluation of the template, the resulting value becomes the new outbasket.</p><p>In the template, the symbol <code>?IN</code> represents the current member from the inbasket; the symbol <code>?OUT</code> represents the entire current outbasket. Other slot symbols should not be used.</p><p>If the first (<var>endtest</var>) input is an empty list, evaluation continues until all inbasket members have been used.  If not, the first input must be a predicate expression template, and evaluation continues until either that template&apos;s value is <code>TRUE</code> or the inbasket is used up.</p>",
            "seeAlso": []
          }
        ]
      }
    ]
  }
]
